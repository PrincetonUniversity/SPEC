
diff --git a/dforce.h b/dforce.h
index ceb9224..667280b 100644
--- a/dforce.h
+++ b/dforce.h
@@ -107,7 +107,7 @@ subroutine dforce( NGdof, position, force, LComputeDerivatives )
   use fileunits, only : ounit
   
   use inputlist, only : Wmacros, Wdforce, ext, Nvol, Mpol, Ntor, Lrad, tflux, Igeometry, &
-                        gamma, adiabatic, pscale, mu, mupftol, &
+                        gamma, adiabatic, pscale, mu, &
                         epsilon, &
                         Lfindzero, &
                         Lconstraint, Lcheck, &
@@ -157,7 +157,7 @@ subroutine dforce( NGdof, position, force, LComputeDerivatives )
                         DDtzcc, DDtzcs, DDtzsc, DDtzss, &
                         DDzzcc, DDzzcs, DDzzsc, DDzzss, &
                         dRodR, dRodZ, dZodR, dZodZ, &
-                        LocalConstraint, xoffset
+                        LocalConstraint
   
 !-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
   
@@ -172,12 +172,7 @@ subroutine dforce( NGdof, position, force, LComputeDerivatives )
   INTEGER, allocatable :: ipivot(:)
   REAL   , allocatable :: work(:)
   
-  INTEGER              :: vvol, innout, ii, jj, irz, issym, iocons, tdoc, idoc, idof, tdof, jdof, ivol, imn, ll, ihybrd, lwa, Ndofgl
-  INTEGER              :: maxfev, ml, muhybr, mode, nprint, nfev, ldfjac, lr
-  DOUBLE PRECISION     :: epsfcn, factor
-  DOUBLE PRECISION     :: Fdof(1:Mvol-1), Xdof(1:Mvol-1), Fvec(1:Mvol-1)
-  DOUBLE PRECISION     :: diag(1:Mvol-1), qtf(1:Mvol-1), wa1(1:Mvol-1), wa2(1:Mvol-1), wa3(1:Mvol-1), wa4(1:mvol-1)
-  DOUBLE PRECISION, allocatable :: fjac(:, :), r(:) 
+  INTEGER              :: vvol, innout, ii, jj, irz, issym, iocons, tdoc, idoc, idof, tdof, jdof, ivol, imn, ll
 
   INTEGER              :: Lcurvature, ideriv, id
   
@@ -189,13 +184,10 @@ subroutine dforce( NGdof, position, force, LComputeDerivatives )
   REAL                 :: dpsi(1:2)
   REAL   , allocatable :: oBI(:,:), rhs(:) ! original Beltrami-matrix inverse; used to compute derivatives of matrix equation;
 
-
   REAL   , allocatable :: dAt(:,:), dAz(:,:), XX(:), YY(:), dBB(:,:), dII(:), dLL(:), dPP(:), length(:), dRR(:,:), dZZ(:,:), constraint(:)
 
   CHARACTER            :: packorunpack 
 
-  EXTERNAL	       :: dfp100
-
 #ifdef DEBUG
   INTEGER              :: isymdiff
   REAL                 :: dRZ = 1.0e-05, dvol(-1:+1), evolume, imupf(1:2,-2:2)
@@ -242,155 +234,33 @@ subroutine dforce( NGdof, position, force, LComputeDerivatives )
   
 !-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
 
-! FIRST COMPUTE MATRICES FOR GIVEN GEOMETRY (dMA, dMB, dMD, ...)
-   do vvol = 1, Mvol
-
-   LREGION(vvol)
-
-   NN = NAdof(vvol) ! shorthand;
-
-   ll = Lrad(vvol)
-
-   SALLOCATE( DToocc, (0:ll,0:ll,1:mn,1:mn), zero )
-   SALLOCATE( DToocs, (0:ll,0:ll,1:mn,1:mn), zero )
-   SALLOCATE( DToosc, (0:ll,0:ll,1:mn,1:mn), zero )
-   SALLOCATE( DTooss, (0:ll,0:ll,1:mn,1:mn), zero )
-
-   SALLOCATE( TTsscc, (0:ll,0:ll,1:mn,1:mn), zero )
-   SALLOCATE( TTsscs, (0:ll,0:ll,1:mn,1:mn), zero )
-   SALLOCATE( TTsssc, (0:ll,0:ll,1:mn,1:mn), zero )
-   SALLOCATE( TTssss, (0:ll,0:ll,1:mn,1:mn), zero )
-
-   SALLOCATE( TDstcc, (0:ll,0:ll,1:mn,1:mn), zero )
-   SALLOCATE( TDstcs, (0:ll,0:ll,1:mn,1:mn), zero )
-   SALLOCATE( TDstsc, (0:ll,0:ll,1:mn,1:mn), zero )
-   SALLOCATE( TDstss, (0:ll,0:ll,1:mn,1:mn), zero )
-
-   SALLOCATE( TDszcc, (0:ll,0:ll,1:mn,1:mn), zero )
-   SALLOCATE( TDszcs, (0:ll,0:ll,1:mn,1:mn), zero )
-   SALLOCATE( TDszsc, (0:ll,0:ll,1:mn,1:mn), zero )
-   SALLOCATE( TDszss, (0:ll,0:ll,1:mn,1:mn), zero )
-
-   SALLOCATE( DDttcc, (0:ll,0:ll,1:mn,1:mn), zero )
-   SALLOCATE( DDttcs, (0:ll,0:ll,1:mn,1:mn), zero )
-   SALLOCATE( DDttsc, (0:ll,0:ll,1:mn,1:mn), zero )
-   SALLOCATE( DDttss, (0:ll,0:ll,1:mn,1:mn), zero )
-
-   SALLOCATE( DDtzcc, (0:ll,0:ll,1:mn,1:mn), zero )
-   SALLOCATE( DDtzcs, (0:ll,0:ll,1:mn,1:mn), zero )
-   SALLOCATE( DDtzsc, (0:ll,0:ll,1:mn,1:mn), zero )
-   SALLOCATE( DDtzss, (0:ll,0:ll,1:mn,1:mn), zero )
-
-   SALLOCATE( DDzzcc, (0:ll,0:ll,1:mn,1:mn), zero )
-   SALLOCATE( DDzzcs, (0:ll,0:ll,1:mn,1:mn), zero )
-   SALLOCATE( DDzzsc, (0:ll,0:ll,1:mn,1:mn), zero )
-   SALLOCATE( DDzzss, (0:ll,0:ll,1:mn,1:mn), zero )
-
-
-   WCALL( dforce, ma00aa, ( Iquad(vvol), mn, vvol, ll ) ) ! compute volume integrals of metric elements - evaluate TD, DT, DD, ...;
-   WCALL( dforce, matrix, ( vvol, mn, ll ) )
-
-
-   DALLOCATE(DToocc)
-   DALLOCATE(DToocs)
-   DALLOCATE(DToosc)
-   DALLOCATE(DTooss)
-
-   DALLOCATE(TTsscc)
-   DALLOCATE(TTsscs)
-   DALLOCATE(TTsssc)
-   DALLOCATE(TTssss)
 
-   DALLOCATE(TDstcc)
-   DALLOCATE(TDstcs)
-   DALLOCATE(TDstsc)
-   DALLOCATE(TDstss)
-
-   DALLOCATE(TDszcc)
-   DALLOCATE(TDszcs)
-   DALLOCATE(TDszsc)
-   DALLOCATE(TDszss)
-
-   DALLOCATE(DDttcc)
-   DALLOCATE(DDttcs)
-   DALLOCATE(DDttsc)
-   DALLOCATE(DDttss)
-
-   DALLOCATE(DDtzcc)
-   DALLOCATE(DDtzcs)
-   DALLOCATE(DDtzsc)
-   DALLOCATE(DDtzss)
-
-   DALLOCATE(DDzzcc)
-   DALLOCATE(DDzzcs)
-   DALLOCATE(DDzzsc)
-   DALLOCATE(DDzzss)
-
-enddo
-
-! NOW SOLVE FOR UNDER CONSTRAINT (GLOBAL OR LOCAL)
   if( LocalConstraint ) then
 
-	! Provide dummy input
-        Xdof(1:Mvol-1) = 0
-	ihybrd	       = 0
-	Fvec(1:Mvol-1) = 0 
-
-        WCALL(dforce, dfp100, (vvol, Xdof, Fvec, ihybrd) )
-
 	do vvol = 1, Mvol
 
+		WCALL(dforce, dfp100, (vvol) )
 		WCALL(dforce, dfp200, ( NGdof, position, LcomputeDerivatives, vvol) )
    
 	enddo ! end of do vvol = 1, Mvol (this is the parallelization loop);
 
   else
 	
+	do vvol = 1, Mvol
 	
-!    WCALL(dforce, dfp100, (vvol, FDof) )
+		WCALL(dforce, dfp100, (vvol) )
 	
-!   If global constraint, start the minimization of the constraint using hybrd1
-    Ndofgl = Mvol-1
-    Xdof(1:Ndofgl)   = dpflux(2:Mvol) + xoffset
-    lwa = 8 * Ndofgl * Ndofgl
-    maxfev = 1000; nfev=0; lr=Mvol*(Mvol-1); ldfjac=Mvol-1
-    ml = Mvol-2; muhybr = Mvol-2; epsfcn=1E-16; diag=0.0; mode=1; factor=10; nprint=-1;
-
-    SALLOCATE(fjac, (1:ldfjac,1:Mvol-1), 0)
-    SALLOCATE(r, (1:lr), 0)
-
-    WCALL( dforce,  hybrd, (dfp100, Ndofgl, Xdof(1:Ndofgl), Fvec(1:Ndofgl), mupftol, maxfev, ml, muhybr, epsfcn, diag(1:Ndofgl), mode, &
-			    factor, nprint, ihybrd, nfev, fjac(1:Ndofgl,1:Ndofgl), ldfjac, r(1:lr), lr, qtf(1:Ndofgl), wa1(1:Ndofgl), &
-			    wa2(1:Ndofgl), wa3(1:Ndofgl), wa4(1:Ndofgl)) ) 
-
-!write(ounit,'("dforce : ", 10x ," : myid=",i3," ; finished computing derivatives of rotational-transform wrt mu and dpflux ;")') myid
-    select case (ihybrd)
-
-	case( 0 )
-	    write(ounit, '("dforce: ", 10x, "Improper input parameter to hybrd")')	
-	case( 1 )
-	    write(ounit, '("dforce: ", 10x, "hybrd: success")')
-	case( 2 )
-	    write(ounit, '("dforce: ", 10x, "hybrd: maximum number of calls reached")')
-	case( 3 )
-	    write(ounit, '("dforce: ", 10x, "hybrd: Tolerance too small. No further improvements are possible.")')
-	case( 4 )
-	    write(ounit, '("dforce: ", 10x, "hybrd: Bad progress")')
-	case( 5 )
-	    write(ounit, '("dforce: ", 10x, "hybrd: Bad progress")')
-    end select
-
-    if(ihybrd .NE. 1) then
-	ImagneticOK = .false.
-    endif
- 
-    dpflux(2:Mvol) = Xdof(1:Ndofgl) - xoffset
- 
+	enddo
+  
+	! EVALUATE THE GLOBAL CONSTRAINT HERE...
+  
     do vvol = 1, Mvol
-	WCALL(dforce, dfp200, ( NGdof, position, LcomputeDerivatives, vvol) )
+		
+		WCALL(dforce, dfp200, ( NGdof, position, LcomputeDerivatives, vvol) )
+    
     enddo
   
-  endif ! matches if( LocalConstraint )
+  endif
 
 
 !-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
diff --git a/dfp100.h b/dfp100.h
index 108af51..5b9e5de 100644
--- a/dfp100.h
+++ b/dfp100.h
@@ -1,4 +1,4 @@
-subroutine dfp100(Ndofgl, x, Fvec, iflag)
+subroutine dfp100(vvol, Fdof, Ddof)
 
 use constants, only : zero, half, one, two, pi2, pi
 
@@ -14,26 +14,27 @@ use allglobal, only : ncpu, myid, cpus, &
                       Mvol, &
                       dBdX, Iquad, &
                       Lcoordinatesingularity, Lplasmaregion, Lvacuumregion, Localconstraint, &
-                      IPDt, dpflux, xoffset
+                      DToocc, DToocs, DToosc, DTooss, &
+                      TTsscc, TTsscs, TTsssc, TTssss, &
+                      TDstcc, TDstcs, TDstsc, TDstss, &
+                      TDszcc, TDszcs, TDszsc, TDszss, &
+                      DDttcc, DDttcs, DDttsc, DDttss, &
+                      DDtzcc, DDtzcs, DDtzsc, DDtzss, &
+                      DDzzcc, DDzzcs, DDzzsc, DDzzss, &
+                      IPDt
 
 
  LOCALS
 !------
 
-INTEGER              :: vvol, NN, ll, ii, Ndofgl, iflag
-DOUBLE PRECISION     :: Fvec(1:Mvol-1), x(1:Mvol-1)
+INTEGER              :: vvol, NN, ll, ii
 
+REAL                 :: Fdof(1:Mvol-1), Ddof(1:Mvol-1)
 
-BEGIN(dfp100)
 
-! First set up the value of dpflux for calculation
 
-dpflux(2:Mvol) = x - xoffset
+  BEGIN(dfp100)
 
-Fvec(1:Mvol-1) = 0.0
-
-! SOLVE FIELD FOR GIVEN GEOMETRY
-do vvol = 1, Mvol
 
    LREGION(vvol) ! assigns Lcoordinatesingularity, Lplasmaregion, etc. ;
 
@@ -47,51 +48,116 @@ do vvol = 1, Mvol
 
    ll = Lrad(vvol)
 
+   SALLOCATE( DToocc, (0:ll,0:ll,1:mn,1:mn), zero )
+   SALLOCATE( DToocs, (0:ll,0:ll,1:mn,1:mn), zero )
+   SALLOCATE( DToosc, (0:ll,0:ll,1:mn,1:mn), zero )
+   SALLOCATE( DTooss, (0:ll,0:ll,1:mn,1:mn), zero )
+
+   SALLOCATE( TTsscc, (0:ll,0:ll,1:mn,1:mn), zero )
+   SALLOCATE( TTsscs, (0:ll,0:ll,1:mn,1:mn), zero )
+   SALLOCATE( TTsssc, (0:ll,0:ll,1:mn,1:mn), zero )
+   SALLOCATE( TTssss, (0:ll,0:ll,1:mn,1:mn), zero )
+
+   SALLOCATE( TDstcc, (0:ll,0:ll,1:mn,1:mn), zero )
+   SALLOCATE( TDstcs, (0:ll,0:ll,1:mn,1:mn), zero )
+   SALLOCATE( TDstsc, (0:ll,0:ll,1:mn,1:mn), zero )
+   SALLOCATE( TDstss, (0:ll,0:ll,1:mn,1:mn), zero )
+
+   SALLOCATE( TDszcc, (0:ll,0:ll,1:mn,1:mn), zero )
+   SALLOCATE( TDszcs, (0:ll,0:ll,1:mn,1:mn), zero )
+   SALLOCATE( TDszsc, (0:ll,0:ll,1:mn,1:mn), zero )
+   SALLOCATE( TDszss, (0:ll,0:ll,1:mn,1:mn), zero )
+
+   SALLOCATE( DDttcc, (0:ll,0:ll,1:mn,1:mn), zero )
+   SALLOCATE( DDttcs, (0:ll,0:ll,1:mn,1:mn), zero )
+   SALLOCATE( DDttsc, (0:ll,0:ll,1:mn,1:mn), zero )
+   SALLOCATE( DDttss, (0:ll,0:ll,1:mn,1:mn), zero )
+
+   SALLOCATE( DDtzcc, (0:ll,0:ll,1:mn,1:mn), zero )
+   SALLOCATE( DDtzcs, (0:ll,0:ll,1:mn,1:mn), zero )
+   SALLOCATE( DDtzsc, (0:ll,0:ll,1:mn,1:mn), zero )
+   SALLOCATE( DDtzss, (0:ll,0:ll,1:mn,1:mn), zero )
+
+   SALLOCATE( DDzzcc, (0:ll,0:ll,1:mn,1:mn), zero )
+   SALLOCATE( DDzzcs, (0:ll,0:ll,1:mn,1:mn), zero )
+   SALLOCATE( DDzzsc, (0:ll,0:ll,1:mn,1:mn), zero )
+   SALLOCATE( DDzzss, (0:ll,0:ll,1:mn,1:mn), zero )
+
 !-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
    
    dBdX%L = .false. ! first, compute Beltrami fields;
    
 !-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
 
+   write( ounit, '("dforce, vvol = ", i3, ". starting ma00aa ...")') vvol
+   WCALL( dfp100, ma00aa, ( Iquad(vvol), mn, vvol, ll ) ) ! compute volume integrals of metric elements - evaluate TD, DT, DD, ...;
+   write( ounit, '("dforce, ma00aa done. starting matrix ... ")')
+   WCALL( dfp100, matrix, ( vvol, mn, ll ) )
+   write( ounit, '("dforce, matrix done. starting ma02aa ... ")')
    WCALL( dfp100, ma02aa, ( vvol, NN ) )
+   write( ounit, '("dforce, ma02aa done.")')
 
 !-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
 
-   5000 continue
+   DALLOCATE(DToocc)
+   DALLOCATE(DToocs)
+   DALLOCATE(DToosc)
+   DALLOCATE(DTooss)
 
-enddo
+   DALLOCATE(TTsscc)
+   DALLOCATE(TTsscs)
+   DALLOCATE(TTsssc)
+   DALLOCATE(TTssss)
 
-! COMPUTE NON LOCAL CONSTRAINTS
-if( .not.LocalConstraint ) then
+   DALLOCATE(TDstcc)
+   DALLOCATE(TDstcs)
+   DALLOCATE(TDstsc)
+   DALLOCATE(TDstss)
 
-	! Use a "select case" instead of an "if" statement to allow additional global constraint to be implemented
-	select case (Lconstraint)
+   DALLOCATE(TDszcc)
+   DALLOCATE(TDszcs)
+   DALLOCATE(TDszsc)
+   DALLOCATE(TDszss)
 
- 		case( 3 )
-			! Compute IPDt on each interface. Eventually need to put the do
-			! loop inside the surfcurent subroutine... TODO
-			do ii = 1, Mvol-1
-				WCALL(dfp100, surfcurent, (ii, mn))
-			enddo
-	
-			Fvec = IPDt - Isurf(1:Mvol-1)
-			!Ddof = ??? TODO: SEE IF AN ANALYTICAL FORMULATION EXISTS... For now, use hybrd1 and not hybrj
+   DALLOCATE(DDttcc)
+   DALLOCATE(DDttcs)
+   DALLOCATE(DDttsc)
+   DALLOCATE(DDttss)
 
-		case default
-			FATAL(dfp100, .true., Unaccepted value for Lconstraint) ! should never happen from definition of LocalConstraint...
+   DALLOCATE(DDtzcc)
+   DALLOCATE(DDtzcs)
+   DALLOCATE(DDtzsc)
+   DALLOCATE(DDtzss)
 
- 	end select
+   DALLOCATE(DDzzcc)
+   DALLOCATE(DDzzcs)
+   DALLOCATE(DDzzsc)
+   DALLOCATE(DDzzss)
 
-#ifdef DEBUG
-	write(ounit, '("dfp100: " 10x ", Fvec = ", es15.8, ", pflux = ", es15.7)') Fvec, dpflux(2:Mvol)
-#endif
+   if( .not.LocalConstraint ) then
 
-endif
+     select case (Lconstraint)
 
+	 case( 3 )
+		! Compute IPDt on each interface. Eventually need to put the do
+		! loop inside the surfcurent subroutine... TODO
+		do ii = 1, Mvol-1
+			WCALL(dfp100, surfcurent, (ii, mn))
+		enddo
+		
+		Fdof = IPDt - Isurf
+		!Ddof = ??? TODO: SEE IF AN ANALYTICAL FORMULATION EXISTS...
 
+	 case default
+		FATAL(dfp100, .true., Unaccepted value for Lconstraint)
 
-RETURN(dfp100)
+	 end select
+   endif
 
-end subroutine dfp100
 
+5000 continue
 
+
+RETURN(dfp100)
+
+end subroutine dfp100
diff --git a/dfp200.h b/dfp200.h
index 05d9902..e5ca463 100644
--- a/dfp200.h
+++ b/dfp200.h
@@ -124,6 +124,19 @@ LREGION(vvol) ! assigns Lcoordinatesingularity, Lplasmaregion, etc. ;
    
    NN = NAdof(vvol) ! shorthand;
    
+!   SALLOCATE( dMA, (0:NN,0:NN), zero ) ! required for both plasma region and vacuum region;
+!   SALLOCATE( dMB, (0:NN,0: 2), zero )
+! !SALLOCATE( dMC, (1: 2,1: 2), zero )
+!   SALLOCATE( dMD, (0:NN,0:NN), zero )
+!  SALLOCATE( dME, (0:NN,1: 2), zero )
+! !SALLOCATE( dMF, (1: 2,1: 2), zero )  
+
+!   SALLOCATE( dMG, (0:NN     ), zero )  
+   
+   
+!   SALLOCATE( MBpsi, (1:NN), zero )
+!  SALLOCATE( MEpsi, (1:NN), zero )
+   
    if( LcomputeDerivatives ) then ! allocate some additional memory;
     
     SALLOCATE( oBI, (1:NN,1:NN), zero ) ! inverse of ``original'', i.e. unperturbed, Beltrami matrix;
diff --git a/ma02aa.h b/ma02aa.h
index 8d0fad7..90ff38b 100644
--- a/ma02aa.h
+++ b/ma02aa.h
@@ -487,7 +487,7 @@ subroutine ma02aa( lvol, NN )
     
 !-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
 
-    if( Lconstraint.eq.1 .or. ( Lvacuumregion .and. Lconstraint.eq.0 ) ) then
+    if( Lconstraint.eq.1 .or. Lconstraint.eq.3 .or. ( Lvacuumregion .and. Lconstraint.eq.0 ) ) then
      
      iflag = 2 ; Ldfjac = Ndof ! call mp00ac: tr00ab/curent to ensure the derivatives of B, transform, currents, wrt mu/dtflux & dpflux are calculated;
 
diff --git a/mp00ac.h b/mp00ac.h
index a6ff109..0bfec2b 100644
--- a/mp00ac.h
+++ b/mp00ac.h
@@ -502,7 +502,7 @@ subroutine mp00ac( Ndof, Xdof, Fdof, Ddof, Ldfjac, iflag ) ! argument list is fi
     
    else ! Lvacuumregion
     
-     FATAL( mp00ac, .true., Lconstraint=3 not implemented in free boundary)
+     FATAL( mp00ac, .true., Lconstraint equal three not implemented in free boundary)
     
    endif ! end of if( Lplasmaregion) ;
 
diff --git a/packxi.h b/packxi.h
index 319f980..7175b28 100644
--- a/packxi.h
+++ b/packxi.h
@@ -180,7 +180,7 @@ subroutine packxi( NGdof, position, Mvol, mn, iRbc, iZbs, iRbs, iZbc, packorunpa
 
    ivol = 1 ! take care with ivol: this variable name might be a global variable, but here it is local; 19 Jul 16; 
  
-   if( (Mvol .ne. 1) .and. (Lfindzero .ne. 0) ) then  
+   if( (Nvol .ne. 1) .and. (Lfindzero .ne. 0) ) then  
     WCALL( packxi, rzaxis, ( Mvol, mn, iRbc(1:mn,0:Mvol), iZbs(1:mn,0:Mvol), iRbs(1:mn,0:Mvol), iZbc(1:mn,0:Mvol), ivol ) ) ! set coordinate axis; 19 Jul 16; 
    endif
 
diff --git a/preset.h b/preset.h
index 1349209..c8dee02 100644
--- a/preset.h
+++ b/preset.h
@@ -432,7 +432,7 @@ end if
 
 ! Allocate space for the toroidal current array in each interface
 
-  SALLOCATE( IPDt, (1:Mvol-1), zero)
+  SALLOCATE( IPDt, (1:Mvol), zero)
 
 !-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
 
diff --git a/surfcurent.h b/surfcurent.h
index a3ab78a..63c42ec 100644
--- a/surfcurent.h
+++ b/surfcurent.h
@@ -134,6 +134,10 @@ subroutine surfcurent(lint, mn)
   call tfft( Nt, Nz, Bt(1:Ntz), Bz(1:Ntz), &
               mn, im(1:mn), in(1:mn), Btemn(1:mn,innout,lvol), Btomn(1:mn,innout,lvol), Bzemn(1:mn,innout,lvol), Bzomn(1:mn,innout,lvol), ifail )
 
+#ifdef DEBUG
+  write(ounit, '("surfcurent : ", f10.2, ", lint=",i3, ", lss=", f10.1, ", lvol=",i3,", Bt(1)=",ES23.15, ", Lcoordsing=", i3)') cput-cpus, lint, lss, lvol, Bt(1), Lcoordinatesingularity
+#endif
+
   enddo ! end of do innout;
 
 ! Get the jump in B_theta in Fourier space for the first even mode.
