!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

!title (free-boundary) ! Constructs magnetic field at external location produced by internal plasma currents.

!latex \briefly{Constructs the field created by the plasma currents, at an arbitrary, external location using virtual casing.}

!latex \calledby{\link{bnorml}}
!      \calls{\link{}}

!latex \tableofcontents

!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

!latex \subsection{theory and numerics}

!latex \begin{enumerate}
!latex \item Required inputs to this subroutine are the geometry of the plasma boundary, 
!latex       \be {\bf x}(\t,\z) \equiv x(\t,\z) {\bf i} + y(\t,\z) {\bf j} + z(\t,\z) {\bf k},
!latex       \ee
!latex       and the tangential field on this boundary, 
!latex       \be {\bf B}_s=B^\t {\bf e}_\t + B^\z {\bf e}_\z,
!latex       \ee
!latex       where $\t$ and $\z$ are arbitrary poloidal and toroidal angles,
!latex       and ${\bf e}_\t \equiv \partial {\bf x}/\partial \t$, ${\bf e}_\z \equiv \partial {\bf x}/\partial \z$.
!latex       This routine assumes that the plasma boundary is a flux surface, i.e. ${\bf B} \cdot {\bf e}_\t \times {\bf e}_\z = 0$.
!latex \item The virtual casing principle 
!latex       [\paper{Shafranov \& Zakharov}{V.D. Shafranov \& L.E. Zakharov}{10.1088/0029-5515/12/5/009}{Nucl. Fusion}{12}{599}{1972},
!latex        \paper{Lazerson}{S.A. Lazerson}{10.1088/0741-3335/54/12/122002}{Plasma Phys. Control. Fusion}{54}{122002}{2012},
!latex        \paper{Hanson}{J.D. Hanson}{10.1088/0741-3335/57/11/115006}{Plasma Phys. Control. Fusion}{57}{115006}{2015}]
!latex       shows that the field outside/inside the plasma arising from plasma currents inside/outside the boundary
!latex       is equivalent to the field generated by a surface current,
!latex       \be {\bf j} = {\bf B}_s \times {\bf n},
!latex       \ee
!latex       where ${\bf n}$ is normal to the surface.
!latex \item The field at some arbitrary point, $\bar {\bf x}$, created by this surface current is given by
!latex       \be {\bf B}({\bf \bar x}) = \int_{\cal S} \frac{\left( {\bf B}_s \times d{\bf s} \right) \times {\bf \hat r}}{r^2},
!latex       \ee
!latex       where $d{\bf s} \equiv {\bf e}_\t \times {\bf e}_\z \; d\t d\z$.
!latex \item For ease of notation introduce
!latex       \be {\bf J} & \equiv & {\bf B}_s \times d{\bf s} = \alpha \; {\bf e}_\t - \beta \; {\bf e}_\z,
!latex       \ee
!latex       where $\alpha \equiv B_\z =  B^\t g_{\t\z} + B^\z g_{\z\z}$ and $\beta \equiv B_\t = B^\t g_{\t\t} + B^\z g_{\t\z}$,
!latex \item We may write in Cartesian coordinates ${\bf J} = j_x \; {\bf i} + j_y \; {\bf j} + j_z \; {\bf k}$, where
!latex       \be j_x     &    =   & \alpha \; x_\t - \beta \; x_\z \\
!latex           j_y     &    =   & \alpha \; y_\t - \beta \; y_\z \\
!latex           j_z     &    =   & \alpha \; z_\t - \beta \; z_\z .
!latex       \ee
!latex \item Requiring that the current,
!latex       \be {\bf j} & \equiv & \nabla \times {\bf B}
!latex                       =      {\sqrt g}^{-1}(\partial_\t B_\z-\partial_\z B_\t) \; {\bf e}_\s
!latex                       +      {\sqrt g}^{-1}(\partial_\z B_\s-\partial_\s B_\z) \; {\bf e}_\t
!latex                       +      {\sqrt g}^{-1}(\partial_\s B_\t-\partial_\t B_\s) \; {\bf e}_\z,
!latex       \ee
!latex       has no normal component to the surface, i.e. ${\bf j}\cdot \nabla s=0$,
!latex       we obtain the condition $\partial_\t B_\z = \partial_\z B_\t$, or $\partial_\t \alpha = \partial_\z \beta$.
!latex       In axisymmetric configurations, where $\partial_\z \beta=0$, we must have $\partial_\t \alpha=0$.
!latex \item The displacement from an arbitrary point, $(X,Y,Z)$, to a point, $(x,y,z)$, that lies on the surface is given 
!latex       \be {\bf r} \equiv r_x \; {\bf i} + r_y \; {\bf j} + r_z \; {\bf k} = (X-x) \; {\bf i} + (Y-y) \; {\bf j} + (Z-z) \; {\bf k}.
!latex       \ee
!latex \item The components of the magnetic field produced by the surface current are then
!latex       \be B^x &=&  \ooint (j_y r_z - j_z r_y)/r^3,\\
!latex           B^y &=&  \ooint (j_z r_x - j_x r_z)/r^3,\\
!latex           B^z &=&  \ooint (j_x r_y - j_y r_x)/r^3
!latex       \ee
!latex \item When all is said and done, this routine calculates
!latex       \be \int_0^{2\pi} \int_0^{2\pi} \verb+vcintegrand+ \;\; d\t d\z
!latex       \ee
!latex       for a given $(X,Y,Z)$, where \verb+vcintegrand+ is given in \Eqn{integrand}.
!latex \item The surface integral is performed using \nag{www.nag.co.uk/numeric/FL/manual19/pdf/D01/d01eaf_fl19.pdf}{D01EAF}, which 
!latex       uses an adaptive subdivision strategy and also computes absolute error estimates.
!latex       The absolute and relative accuracy required are provided by the input \inputvar{vcasingtol}.
!latex       The minimum number of function evaluations is provided by the input \inputvar{vcasingits}.
!l tex \item It may be convenient to have the derivatives:
!l tex       \be \frac{\partial B^x}{\partial x} & = & \ooint \left[ -3 (j_y r_z - j_z r_y) (X-x) / r^5 \;\;\;\;\;\;\;\;\;\;\;\;     \right], \\
!l tex           \frac{\partial B^x}{\partial y} & = & \ooint \left[ -3 (j_y r_z - j_z r_y) (Y-y) / r^5 - j_z/r^3                    \right], \\
!l tex           \frac{\partial B^x}{\partial z} & = & \ooint \left[ -3 (j_y r_z - j_z r_y) (Z-z) / r^5 + j_y/r^3                    \right], \\
!l tex           \frac{\partial B^y}{\partial x} & = & \ooint \left[ -3 (j_z r_x - j_x r_z) (X-x) / r^5 + j_z/r^3                    \right], \\
!l tex           \frac{\partial B^y}{\partial y} & = & \ooint \left[ -3 (j_z r_x - j_x r_z) (Y-y) / r^5 \;\;\;\;\;\;\;\;\;\;\;\;\;   \right], \\
!l tex           \frac{\partial B^y}{\partial z} & = & \ooint \left[ -3 (j_z r_x - j_x r_z) (Z-z) / r^5 - j_x/r^3                    \right], \\
!l tex           \frac{\partial B^z}{\partial x} & = & \ooint \left[ -3 (j_x r_y - j_y r_x) (X-x) / r^5 - j_y/r^3                    \right], \\
!l tex           \frac{\partial B^z}{\partial y} & = & \ooint \left[ -3 (j_x r_y - j_y r_x) (Y-y) / r^5 + j_x/r^3                    \right], \\
!l tex           \frac{\partial B^z}{\partial z} & = & \ooint \left[ -3 (j_x r_y - j_y r_x) (Z-z) / r^5 \;\;\;\;\;\;\;\;\;\;\;\;\;   \right].
!l tex       \ee
!latex \end{enumerate}

!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

subroutine casing( teta, zeta, gBn, icasing )
  
!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
  use constants, only : zero, pi, pi2
  
  use numerical, only : 
  
  use fileunits, only : ounit, vunit
  
  use inputlist, only : Wmacros, Wcasing, ext, vcasingtol, vcasingits, vcasingper
  
  use cputiming, only : Tcasing
  
  use allglobal, only : myid, ncpu, cpus, globaljk, Dxyz, Nxyz
  
!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
  LOCALS
  
  REAL, intent(in)   :: teta, zeta ! arbitrary location; Cartesian;
  REAL, intent(out)  :: gBn ! magnetic field; Cartesian;
  INTEGER            :: icasing
  
  INTEGER, parameter :: Ndim = 2, Nfun = 1

  INTEGER            :: ldim, lfun, minpts, maxpts, Lrwk, idcuhre, jk, irestart, funcls, key, num, maxsub
  REAL               :: integrals(1:Nfun), low(1:Ndim), upp(1:Ndim), labs, lrel, absest(1:Nfun)
  REAL, allocatable  :: rwk(:)
  
! REAL               :: dvcfield
  external           :: dvcfield
  
  BEGIN(casing)
  
!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
  jk = globaljk ! shorthand; globaljk is a "global" variable which must be passed through to subroutine dvcfield;
  
!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
  gBn = zero ! initialize intent(out);
  
!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
  ldim = Ndim ! number of dimensions of the integral; surface integral => number of dimensions = 2;
  
  low(1) = teta - vcasingper * pi ; upp(1) = teta + vcasingper * pi
  low(2) = zeta - vcasingper * pi ; upp(2) = zeta + vcasingper * pi

  key = 0

  minpts = vcasingits ! minimum number of function evaluations; provided on input;

  num = 65 ! see documentation for dcuhre;

  maxpts = max( minpts, 3 * num )
  
  lfun = Nfun ! number of functions to be integrated; require three components of magnetic field, Bx, By and Bz; and their derivatives wrt x,y,z;
  
  labs = vcasingtol ; lrel = vcasingtol ! absolute and relative accuracy requested; vcasingtol is an input parameter;
  
  maxsub = ( maxpts - num ) / ( 2 * num ) + 1

  Lrwk = maxsub * ( 2 * Ndim + 2 * Nfun + 2 ) + 17 * Nfun + 1

  SALLOCATE( rwk, (1:Lrwk), zero )
  
  irestart = 0 ; funcls = 0

  do ! will continually call until satisfactory accuracy has been achieved;
   
   idcuhre = 1
   
   call DCUHRE( ldim, lfun, low(1:Ndim), upp(1:Ndim), minpts, maxpts, dvcfield, labs, lrel, key, &
                Lrwk, irestart, integrals(1:lfun), absest(1:lfun), funcls, idcuhre, rwk(1:Lrwk) )
   
   gBn = integrals(1)
   
   cput = GETTIME
   select case( idcuhre ) !                                                                                          "123456789012345678901234"
   case(0)      ;
    ;           ; exit
   case(1)      ; write(ounit,1001) cput-cpus, myid, Dxyz(1:3,jk), gBn, absest(1:Nfun), idcuhre, minpts, maxpts, "maxpts too smal;        "
    ;           ;!exit
   case(2)      ; write(ounit,1001) cput-cpus, myid, Dxyz(1:3,jk), gBn, absest(1:Nfun), idcuhre, minpts, maxpts, "illegal key;            "
    ;           ; exit
   case(3)      ; write(ounit,1001) cput-cpus, myid, Dxyz(1:3,jk), gBn, absest(1:Nfun), idcuhre, minpts, maxpts, "illegal Ndim;           "
    ;           ; exit
   case(4)      ; write(ounit,1001) cput-cpus, myid, Dxyz(1:3,jk), gBn, absest(1:Nfun), idcuhre, minpts, maxpts, "key.eq.1 & Ndim.ne.2;   "
    ;           ; exit
   case(5)      ; write(ounit,1001) cput-cpus, myid, Dxyz(1:3,jk), gBn, absest(1:Nfun), idcuhre, minpts, maxpts, "key.eq.2 & Ndim.ne.3;   "
    ;           ; exit
   case(6)      ; write(ounit,1001) cput-cpus, myid, Dxyz(1:3,jk), gBn, absest(1:Nfun), idcuhre, minpts, maxpts, "numfun < 1;             "
    ;           ; exit
   case(7)      ; write(ounit,1001) cput-cpus, myid, Dxyz(1:3,jk), gBn, absest(1:Nfun), idcuhre, minpts, maxpts, "volume is zero;         "
    ;           ; exit
   case(8)      ; write(ounit,1001) cput-cpus, myid, Dxyz(1:3,jk), gBn, absest(1:Nfun), idcuhre, minpts, maxpts, "maxpts < 3*NUM;         "
    ;           ; exit
   case(9)      ; write(ounit,1001) cput-cpus, myid, Dxyz(1:3,jk), gBn, absest(1:Nfun), idcuhre, minpts, maxpts, "maxpts < minpts;        "
    ;           ; exit
   case(10)     ; write(ounit,1001) cput-cpus, myid, Dxyz(1:3,jk), gBn, absest(1:Nfun), idcuhre, minpts, maxpts, "epsabs < 0 & epsrel < 0;"
    ;           ; exit
   case(11)     ; write(ounit,1001) cput-cpus, myid, Dxyz(1:3,jk), gBn, absest(1:Nfun), idcuhre, minpts, maxpts, "NW is too small;        "
    ;           ; exit
   case(12)     ; write(ounit,1001) cput-cpus, myid, Dxyz(1:3,jk), gBn, absest(1:Nfun), idcuhre, minpts, maxpts, "illegal irestart;       "
    ;           ; exit
   case default ; write(ounit,1001) cput-cpus, myid, Dxyz(1:3,jk), gBn, absest(1:Nfun), idcuhre, minpts, maxpts, "tryin' to kill me?      "
    ;           ; exit
   end select
   
   maxpts = 2 * maxpts ; minpts = funcls ; irestart = 1

  enddo ! end of virtual casing accuracy infinite-do-loop; 10 Apr 13;

#ifdef DEBUG
  ;             ; if( Wcasing ) write(ounit,1001) cput-cpus, myid, Dxyz(1:3,jk), gBn, absest(1:Nfun), idcuhre, minpts, maxpts
#endif
  
1001 format("casing : ",f10.2," : myid=",i3," ; [x,y,z]=["es10.2" ,"es10.2" ,"es10.2" ]; gBn="es12.4" , ",&
            "err="es8.0" ; ifail="i3" ; min/max calls="2i12" ; "a24)

!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

  icasing = idcuhre ! this is an error flag returned by casing;
  
!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
  DALLOCATE(rwk)
  
!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
  RETURN(casing)
  
!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
end subroutine casing

!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

!latex \subsection{calculation of integrand}

!latex \begin{enumerate}
!latex \item An adaptive integration is used to compute the integrals.
!latex       Consequently, the magnetic field tangential to the plasma boundary is required at an arbitrary point.
!latex       This is computed, as always, from ${\bf B} = \nabla \times {\bf A}$, and this provides ${\bf B} = B^\t {\bf e}_\t + B^\z {\bf e}_\z$.
!latex       (Recall that $B^s=0$ by construction on the plasma boundary.)
!latex       (It would be MUCH faster to only require the tangential field on a regular grid!!!)
!latex \item Then, the metric elements $g_{\t\t}$, $g_{\t\z}$ and $g_{\z\z}$ are computed.
!latex       These are used to ``lower'' the components of the magnetic field, ${\bf B} = B_\t \nabla \t + B_\z \nabla \z$.
!latex       (Please check why $B_s$ is not computed. Is it because $B_s \nabla s \times {\bf n} = 0$ ?)
!latex \item The distance between the ``evaluate'' point, $(X,Y,Z)$, and the given point on the surface, $(x,y,z)$ is computed.
!latex \item If the computational boundary becomes too close to the plasma boundary, the distance is small and this causes problems for the numerics.
!latex       I have tried to regularize this problem by introducing $\epsilon \equiv $\inputvar{vcasingeps}.
!latex       Let the ``distance'' be
!latex       \be D \equiv \sqrt{(X-x)^2 + (Y-y)^2 + (Z-Z)^2} + \epsilon^2.
!latex       \ee
!latex \item On taking the limit that $\epsilon \rightarrow 0$, the virtual casing integrand is 
!latex        \be \verb+vcintegrand+ \equiv ( B_x n_x + B_y n_y + B_z n_z ) ( 1 + 3 \epsilon^2 / D^2 ) / D^3, \label{eq:integrand}
!latex        \ee
!latex       where the normal vector is ${\bf n} \equiv n_x {\bf i} + n_y {\bf j} + n_z {\bf k}$.
!latex       The normal vector, \internal{Nxyz}, to the computational boundary (which does not change) is computed in \link{preset}.
!latex       This needs to be revised.
!latex \end{enumerate}

!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

subroutine dvcfield( Ndim, tz, Nfun, vcintegrand ) ! differential virtual-casing field; format is fixed by NAG requirements;
  
!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
  use constants, only : zero, half, one, three
  
  use numerical, only :
  
  use fileunits, only : ounit, vunit
  
  use inputlist, only : Wcasing, Nvol, Igeometry, Lrad, vcasingeps
  
  use cputiming, only : 

  use allglobal, only : myid, ncpu, cpus, pi2nfp, &
                        Mvol, &
                        mn, im, in, &
                        iRbc, iZbs, iRbs, iZbc, &
                        Ate, Aze, Ato, Azo, &
                        TT, &
                        YESstellsym, NOTstellsym, &
                        globaljk, Dxyz, Nxyz
  
!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
  LOCALS
  
  INTEGER , intent(in)  :: Ndim, Nfun
  REAL    , intent(in)  :: tz(1:Ndim)
  REAL    , intent(out) :: vcintegrand(1:Nfun) ! integrand; components of magnetic field due to plasma currents in Cartesian coordinates;
  
  INTEGER               :: ii, mi, ni, ll, ideriv, jk
  REAL                  :: dR(0:3), dZ(0:3), gBut, gBuz, gtt, gtz, gzz, sqrtg, Blt, Blz, czeta, szeta, arg, carg, sarg, XX, YY, ZZ, teta, zeta
  REAL                  :: jj(1:3), rr(1:3), distance(1:3), firstorderfactor
  
  REAL                  :: XXt, XXz, YYt, YYz, ZZt, ZZz, ds, Bxyz(1:3)

!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
#ifdef DEBUG
  FATAL( casing, Ndim.ne. 2, incorrect )
  FATAL( casing, Nfun.ne. 1, incorrect )
#endif
  
!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
  dR(0:3) = zero ; ideriv = 0 ; gBut = zero ; gBuz = zero ! initialize summation of coordinates and tangential field;
  dZ(0:3) = zero
  
  teta = tz(1) ; zeta = tz(2) ! shorthand; 09 Mar 17;

  jk = globaljk

!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

  select case( Igeometry )
   
  case( 1 ) ! Igeometry = 1 ; 09 Mar 17;
   
   if( YESstellsym ) then
    
    do ii = 1, mn ; mi = im(ii) ; ni = in(ii) ! loop over Fourier modes; construct surface current; slow transform required as position is arbitrary;
     
     arg = mi * teta - ni * zeta ; carg = cos(arg) ; sarg = sin(arg)
     
     dR(0) = dR(0) +          (                   iRbc(ii,Nvol) ) * carg                                            
     dR(1) = dR(1) +      (   (   iRbc(ii,Mvol) - iRbc(ii,Nvol) ) * carg                                            ) * half
     dR(2) = dR(2) + mi * ( - (                   iRbc(ii,Nvol) ) * sarg                                            )
     dR(3) = dR(3) - ni * ( - (                   iRbc(ii,Nvol) ) * sarg                                            )

    !dZ(0) = dZ(0) +                                                       (                 iZbs(ii,Nvol) ) * sarg 
    !dZ(1) = dZ(1) +      (                                                ( iZbs(ii,Mvol) - iZbs(ii,Nvol) ) * sarg ) * half
    !dZ(2) = dZ(2) + mi * (                                                (                 iZbs(ii,Nvol) ) * carg )
    !dZ(3) = dZ(3) - ni * (                                                (                 iZbs(ii,Nvol) ) * carg )
    
     do ll = 0, Lrad(Mvol)
      gBut = gBut - ( Aze(Mvol,ideriv,ii)%s(ll) * carg                                    ) * TT(ll,0,1) ! contravariant; Jacobian comes later; 
      gBuz = gBuz + ( Ate(Mvol,ideriv,ii)%s(ll) * carg                                    ) * TT(ll,0,1)
     enddo
     
    enddo ! end of do ii = 1, mn ;
    
   else ! NOTstellsym ; 08 Feb 16;
    
    do ii = 1, mn ; mi = im(ii) ; ni = in(ii) ! loop over Fourier modes; construct surface current; slow transform required as position is arbitrary;
     
     arg = mi * teta - ni * zeta ; carg = cos(arg) ; sarg = sin(arg)
     
     dR(0) = dR(0) +                              iRbc(ii,Nvol)   * carg +                   iRbs(ii,Nvol)   * sarg 
     dR(1) = dR(1) +      (   (   iRbc(ii,Mvol) - iRbc(ii,Nvol) ) * carg + ( iRbs(ii,Mvol) - iRbs(ii,Nvol) ) * sarg ) * half
     dR(2) = dR(2) + mi * ( -                     iRbc(ii,Nvol)   * sarg +                   iRbs(ii,Nvol)   * carg )
     dR(3) = dR(3) - ni * ( -                     iRbc(ii,Nvol)   * sarg +                   iRbs(ii,Nvol)   * carg )

    !dZ(0) = dZ(0) +                              iZbc(ii,Nvol)   * carg +                   iZbs(ii,Nvol)   * sarg 
    !dZ(1) = dZ(1) +      (   (   iZbc(ii,Mvol) - iZbc(ii,Nvol) ) * carg + ( iZbs(ii,Mvol) - iZbs(ii,Nvol) ) * sarg ) * half
    !dZ(2) = dZ(2) + mi * ( -                     iZbc(ii,Nvol)   * sarg +                   iZbs(ii,Nvol)   * carg )
    !dZ(3) = dZ(3) - ni * ( -                     iZbc(ii,Nvol)   * sarg +                   iZbs(ii,Nvol)   * carg )
    
     do ll = 0, Lrad(Mvol)
      gBut = gBut - ( Aze(Mvol,ideriv,ii)%s(ll) * carg + Azo(Mvol,ideriv,ii)%s(ll) * sarg ) * TT(ll,0,1) ! contravariant; Jacobian comes later; 
      gBuz = gBuz + ( Ate(Mvol,ideriv,ii)%s(ll) * carg + Ato(Mvol,ideriv,ii)%s(ll) * sarg ) * TT(ll,0,1)
     enddo
     
    enddo ! end of do ii = 1, mn ;
    
   endif ! end of if( YESstellsym ) ; 08 Feb 16;
   
  case( 2 ) ! Igeometry = 2 ; 09 Mar 17;
   
   FATAL( casing, .true., virtual casing under construction for cylindrical geometry )
   
  case( 3 ) ! Igeometry = 3 ; 09 Mar 17;
   
   if( YESstellsym ) then
    
    do ii = 1, mn ; mi = im(ii) ; ni = in(ii) ! loop over Fourier modes; construct surface current; slow transform required as position is arbitrary;
     
     arg = mi * teta - ni * zeta ; carg = cos(arg) ; sarg = sin(arg)
     
     dR(0) = dR(0) +          (                   iRbc(ii,Nvol) ) * carg                                            
     dR(1) = dR(1) +      (   (   iRbc(ii,Mvol) - iRbc(ii,Nvol) ) * carg                                            ) * half
     dR(2) = dR(2) + mi * ( - (                   iRbc(ii,Nvol) ) * sarg                                            )
     dR(3) = dR(3) - ni * ( - (                   iRbc(ii,Nvol) ) * sarg                                            )
     
     dZ(0) = dZ(0) +                                                       (                 iZbs(ii,Nvol) ) * sarg 
     dZ(1) = dZ(1) +      (                                                ( iZbs(ii,Mvol) - iZbs(ii,Nvol) ) * sarg ) * half
     dZ(2) = dZ(2) + mi * (                                                (                 iZbs(ii,Nvol) ) * carg )
     dZ(3) = dZ(3) - ni * (                                                (                 iZbs(ii,Nvol) ) * carg )
     
     do ll = 0, Lrad(Mvol)
      gBut = gBut - ( Aze(Mvol,ideriv,ii)%s(ll) * carg                                    ) * TT(ll,0,1) ! contravariant; Jacobian comes later; 
      gBuz = gBuz + ( Ate(Mvol,ideriv,ii)%s(ll) * carg                                    ) * TT(ll,0,1)
     enddo
     
    enddo ! end of do ii = 1, mn ;
    
   else ! NOTstellsym ; 08 Feb 16;
    
    do ii = 1, mn ; mi = im(ii) ; ni = in(ii) ! loop over Fourier modes; construct surface current; slow transform required as position is arbitrary;
     
     arg = mi * teta - ni * zeta ; carg = cos(arg) ; sarg = sin(arg)
     
     dR(0) = dR(0) +                              iRbc(ii,Nvol)   * carg +                   iRbs(ii,Nvol)   * sarg 
     dR(1) = dR(1) +      (   (   iRbc(ii,Mvol) - iRbc(ii,Nvol) ) * carg + ( iRbs(ii,Mvol) - iRbs(ii,Nvol) ) * sarg ) * half
     dR(2) = dR(2) + mi * ( -                     iRbc(ii,Nvol)   * sarg +                   iRbs(ii,Nvol)   * carg )
     dR(3) = dR(3) - ni * ( -                     iRbc(ii,Nvol)   * sarg +                   iRbs(ii,Nvol)   * carg )
     
     dZ(0) = dZ(0) +                              iZbc(ii,Nvol)   * carg +                   iZbs(ii,Nvol)   * sarg 
     dZ(1) = dZ(1) +      (   (   iZbc(ii,Mvol) - iZbc(ii,Nvol) ) * carg + ( iZbs(ii,Mvol) - iZbs(ii,Nvol) ) * sarg ) * half
     dZ(2) = dZ(2) + mi * ( -                     iZbc(ii,Nvol)   * sarg +                   iZbs(ii,Nvol)   * carg )
     dZ(3) = dZ(3) - ni * ( -                     iZbc(ii,Nvol)   * sarg +                   iZbs(ii,Nvol)   * carg )
     
     do ll = 0, Lrad(Mvol)
      gBut = gBut - ( Aze(Mvol,ideriv,ii)%s(ll) * carg + Azo(Mvol,ideriv,ii)%s(ll) * sarg ) * TT(ll,0,1) ! contravariant; Jacobian comes later; 
      gBuz = gBuz + ( Ate(Mvol,ideriv,ii)%s(ll) * carg + Ato(Mvol,ideriv,ii)%s(ll) * sarg ) * TT(ll,0,1)
     enddo
     
    enddo ! end of do ii = 1, mn ;
    
   endif ! end of if( YESstellsym ) ; 08 Feb 16;
  
  end select ! end of select case( Igeometry ) ; 09 Mar 17;

!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
  select case( Igeometry )
   
  case( 1 ) ! Igeometry = 1 ; 09 Mar 17;
   
   gtt = one + dR(2)*dR(2)
   gtz =       dR(2)*dR(3)
   gzz = one + dR(3)*dR(3)
   
   sqrtg = dR(1)
   
  case( 2 ) ! Igeometry = 2 ; 09 Mar 17;
   
   FATAL( casing, .true., virtual casing under construction for cylindrical geometry )
   
  case( 3 ) ! Igeometry = 3 ; 09 Mar 17;
   
   gtt = dR(2)*dR(2) + dZ(2)*dZ(2)
   gtz = dR(2)*dR(3) + dZ(2)*dZ(3)
   gzz = dR(3)*dR(3) + dZ(3)*dZ(3) + dR(0)*dR(0)
   
   sqrtg = dR(0) * ( dZ(1) * dR(2) - dR(1) * dZ(2) )
   
  end select
  
!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

  Blt = ( gBut * gtt + gBuz * gtz ) / sqrtg
  Blz = ( gBut * gtz + gBuz * gzz ) / sqrtg
   
!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
  select case( Igeometry )
   
  case( 1 ) ! Igeometry = 1 ; 09 Mar 17;
   
   XX =          teta ; XXt =           one ; XXz =          zero
   YY =          zeta ; YYt =          zero ; YYz =           one
   ZZ = dR(0)         ; ZZt = dR(2)         ; ZZz = dR(3)
   
  case( 2 ) ! Igeometry = 2 ; 09 Mar 17;
   
   FATAL( casing, .true., virtual casing under construction for cylindrical geometry )
   
  case( 3 ) ! Igeometry = 3 ; toroidal geometry;
   
   czeta = cos( zeta ) ; szeta = sin( zeta )

   XX = dR(0) * czeta ; XXt = dR(2) * czeta ; XXz = dR(3) * czeta - dR(0) * szeta ! 10 Apr 13;
   YY = dR(0) * szeta ; YYt = dR(2) * szeta ; YYz = dR(3) * szeta + dR(0) * czeta   
   ZZ = dZ(0)         ; ZZt = dZ(2)         ; ZZz = dZ(3)
   
  end select

!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

  rr(1:3) = (/ Dxyz(1,jk) - XX, &
               Dxyz(2,jk) - YY, &
               Dxyz(3,jk) - ZZ /)

  jj(1:3) = (/ Blz * XXt - Blt * XXz, &
               Blz * YYt - Blt * YYz, &
               Blz * ZZt - Blt * ZZz /)
  
!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
  distance(2) = sum( rr(1:3) * rr(1:3) ) + vcasingeps**2 ! 04 May 17;
  
  distance(1) = sqrt( distance(2) ) ; distance(3) = distance(1) * distance(2) ! powers of distance; 24 Nov 16;
  
  firstorderfactor = ( one + three * vcasingeps**2 / distance(2) ) / distance(3) ! 04 May 17;
  
!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
  Bxyz(1:3) = (/ jj(2) * rr(3) - jj(3) * rr(2), &
                 jj(3) * rr(1) - jj(1) * rr(3), &
                 jj(1) * rr(2) - jj(2) * rr(1)  /)

  vcintegrand(1) = sum( Bxyz(1:3) * Nxyz(1:3,jk) ) * firstorderfactor
  
!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

!   vcintegrand( 4) = - three * vcintegrand(1) * rr(1) / distance(2)         ! dBxdx; ! need to divide by distance(3) ; 14 Apr 17;
!   vcintegrand( 5) = - three * vcintegrand(1) * rr(2) / distance(2) - jj(3) ! dBxdy;
!   vcintegrand( 6) = - three * vcintegrand(1) * rr(3) / distance(2) + jj(2) ! dBxdz;
!   
!   vcintegrand( 7) = - three * vcintegrand(2) * rr(1) / distance(2) + jj(3) ! dBydx;
!   vcintegrand( 8) = - three * vcintegrand(2) * rr(2) / distance(2)         ! dBydy;
!   vcintegrand( 9) = - three * vcintegrand(2) * rr(3) / distance(2) - jj(1) ! dBydz;
!   
!   vcintegrand(10) = - three * vcintegrand(3) * rr(1) / distance(2) - jj(2) ! dBzdx;
!   vcintegrand(11) = - three * vcintegrand(3) * rr(2) / distance(2) + jj(1) ! dBzdy;
!   vcintegrand(12) = - three * vcintegrand(3) * rr(3) / distance(2)         ! dBzdz;
  
!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
  return
  
!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
end subroutine dvcfield

!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
