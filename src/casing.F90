!> \file
!> \brief Constructs the field created by the plasma currents, at an arbitrary, external location using virtual casing.

!> \brief Constructs the field created by the plasma currents, at an arbitrary, external location using virtual casing.
!> \ingroup grp_free-boundary
!>
!> Compute the external magnetic field using virtual casing.
!>
!> **Theory and numerics**
!>
!> <ul>
!> <li> Required inputs to this subroutine are the geometry of the plasma boundary,
!>      \f{eqnarray}{ {\bf x}(\theta,\zeta) \equiv x(\theta,\zeta) {\bf i} + y(\theta,\zeta) {\bf j} + z(\theta,\zeta) {\bf k},
!>      \f}
!>      and the tangential field on this boundary,
!>      \f{eqnarray}{ {\bf B}_s=B^\theta {\bf e}_\theta + B^\zeta {\bf e}_\zeta,
!>      \f}
!>      where \f$\theta\f$ and \f$\zeta\f$ are arbitrary poloidal and toroidal angles,
!>      and \f${\bf e}_\theta \equiv \partial {\bf x}/\partial \theta\f$, \f${\bf e}_\zeta \equiv \partial {\bf x}/\partial \zeta\f$.
!>      This routine assumes that the plasma boundary is a flux surface, i.e. \f${\bf B} \cdot {\bf e}_\theta \times {\bf e}_\zeta = 0\f$. </li>
!> <li> The virtual casing principle (Shafranov & Zakharov (1972) \cite y1972_shafranov_zakharov, Lazerson (2012) \cite y2012_lazerson and Hanson (2015) \cite y2015_hanson)
!>      shows that the field outside/inside the plasma arising from plasma currents inside/outside the boundary
!>      is equivalent to the field generated by a surface current,
!>      \f{eqnarray}{ {\bf j} = {\bf B}_s \times {\bf n},
!>      \f}
!>      where \f${\bf n}\f$ is normal to the surface. </li>
!> <li> The field at some arbitrary point, \f$\bar {\bf x}\f$, created by this surface current is given by
!>      \f{eqnarray}{ {\bf B}({\bf \bar x}) = -\frac{1}{4\pi} \int_{\cal S} \frac{\left( {\bf B}_s \times d{\bf s} \right) \times {\bf \hat r}}{r^2},
!>      \f}
!>      where \f$d{\bf s} \equiv {\bf e}_\theta \times {\bf e}_\zeta \; d\theta d\zeta\f$. </li>
!> <li> For ease of notation introduce
!>      \f{eqnarray}{ {\bf J} & \equiv & {\bf B}_s \times d{\bf s} = \alpha \; {\bf e}_\theta - \beta \; {\bf e}_\zeta,
!>      \f}
!>      where \f$\alpha \equiv B_\zeta =  B^\theta g_{\theta\zeta} + B^\zeta g_{\zeta\zeta}\f$ and \f$\beta \equiv B_\theta = B^\theta g_{\theta\theta} + B^\zeta g_{\theta\zeta}\f$. </li>
!> <li> We may write in Cartesian coordinates \f${\bf J} = j_x \; {\bf i} + j_y \; {\bf j} + j_z \; {\bf k}\f$, where
!>      \f{eqnarray}{ j_x     &    =   & \alpha \; x_\theta - \beta \; x_\zeta \\
!>                    j_y     &    =   & \alpha \; y_\theta - \beta \; y_\zeta \\
!>                    j_z     &    =   & \alpha \; z_\theta - \beta \; z_\zeta .
!>      \f} </li>
!> <li> Requiring that the current,
!>      \f{eqnarray}{ {\bf j} & \equiv & \nabla \times {\bf B}
!>                      =      {\sqrt g}^{-1}(\partial_\theta B_\zeta -\partial_\zeta  B_\theta) \; {\bf e}_s
!>                      +      {\sqrt g}^{-1}(\partial_\zeta  B_s     -\partial_s      B_\zeta ) \; {\bf e}_\theta
!>                      +      {\sqrt g}^{-1}(\partial_s      B_\theta-\partial_\theta B_s     ) \; {\bf e}_\zeta,
!>      \f}
!>      has no normal component to the surface, i.e. \f${\bf j}\cdot \nabla s=0\f$,
!>      we obtain the condition \f$\partial_\theta B_\zeta = \partial_\zeta B_\theta\f$, or \f$\partial_\theta \alpha = \partial_\zeta \beta\f$.
!>      In axisymmetric configurations, where \f$\partial_\zeta \beta=0\f$, we must have \f$\partial_\theta \alpha=0\f$. </li>
!> <li> The displacement from an arbitrary point, \f$(X,Y,Z)\f$, to a point, \f$(x,y,z)\f$, that lies on the surface is given
!>      \f{eqnarray}{ {\bf r} \equiv r_x \; {\bf i} + r_y \; {\bf j} + r_z \; {\bf k} = (X-x) \; {\bf i} + (Y-y) \; {\bf j} + (Z-z) \; {\bf k}.
!>      \f} </li>
!> <li> The components of the magnetic field produced by the surface current are then
!>      \f{eqnarray}{ B^x &=& \oint\!\!\!\oint \!d\theta d\zeta \,\,\, (j_y r_z - j_z r_y)/r^3,\\
!>                    B^y &=& \oint\!\!\!\oint \!d\theta d\zeta \,\,\, (j_z r_x - j_x r_z)/r^3,\\
!>                    B^z &=& \oint\!\!\!\oint \!d\theta d\zeta \,\,\, (j_x r_y - j_y r_x)/r^3
!>      \f}
!>      up to a scaling factor \c virtualcasingfactor  \f$=-1/4\pi\f$ that is taken into account at the end. </li>
!> <li> When all is said and done, this routine calculates
!>      \f{eqnarray}{ \int_0^{2\pi} \int_0^{2\pi} \verb+vcintegrand+ \;\; d\theta d\zeta
!>      \f}
!>      for a given \f$(X,Y,Z)\f$, where \c vcintegrand  is given in Eqn.\f$(\ref{eq:integrand_casing})\f$. </li>
!> <li> The surface integral is performed using \c DCUHRE , which
!>      uses an adaptive subdivision strategy and also computes absolute error estimates.
!>      The absolute and relative accuracy required are provided by the \c inputvar \c vcasingtol .
!>      The minimum number of function evaluations is provided by the \c inputvar \c vcasingits. </li>
!> </ul>
!>
!> **Calculation of integrand**
!>
!> <ul>
!> <li> An adaptive integration is used to compute the integrals.
!>      Consequently, the magnetic field tangential to the plasma boundary is required at an arbitrary point.
!>      This is computed, as always, from \f${\bf B} = \nabla \times {\bf A}\f$, and this provides \f${\bf B} = B^\theta {\bf e}_\theta + B^\zeta {\bf e}_\zeta\f$.
!>      Recall that \f$B^s=0\f$ by construction on the plasma boundary.
!>      \todo It would be MUCH faster to only require the tangential field on a regular grid!!!
!>
!> </li>
!> <li> Then, the metric elements \f$g_{\theta\theta}\f$, \f$g_{\theta\zeta}\f$ and \f$g_{\zeta\zeta}\f$ are computed.
!>      These are used to "lower" the components of the magnetic field, \f${\bf B} = B_\theta \nabla \theta + B_\zeta \nabla \zeta\f$.
!>      \todo Please check why \f$B_s\f$ is not computed. Is it because \f$B_s \nabla s \times {\bf n} = 0\f$ ?
!>
!> </li>
!> <li> The distance between the "evaluate" point, \f$(X,Y,Z)\f$, and the given point on the surface, \f$(x,y,z)\f$ is computed. </li>
!> <li> If the computational boundary becomes too close to the plasma boundary, the distance is small and this causes problems for the numerics.
!>      I have tried to regularize this problem by introducing \f$\epsilon \equiv \f$\c inputvar \c vcasingeps.
!>      Let the "distance" be
!>      \f{eqnarray}{ D \equiv \sqrt{(X-x)^2 + (Y-y)^2 + (Z-Z)^2} + \epsilon^2.
!>      \f} </li>
!> <li> On taking the limit that \f$\epsilon \rightarrow 0\f$, the virtual casing integrand is
!>       \f{eqnarray}{ \verb+vcintegrand+ \equiv ( B_x n_x + B_y n_y + B_z n_z ) ( 1 + 3 \epsilon^2 / D^2 ) / D^3, \label{eq:integrand_casing}
!>       \f}
!>      where the normal vector is \f${\bf n} \equiv n_x {\bf i} + n_y {\bf j} + n_z {\bf k}\f$.
!>      The normal vector, \c Nxyz , to the computational boundary (which does not change) is computed in preset().
!>      \todo This needs to be revised.
!>
!> </li>
!> </ul>
!>
!> @param[in] teta \f$\theta\f$
!> @param[in] zeta \f$\zeta\f$
!> @param[out] gBn \f$ \sqrt g {\bf B} \cdot {\bf n}\f$
!> @param[out] icasing return flag from dcuhre()
subroutine casing( teta, zeta, gBn, icasing )
  use mod_kinds, only: wp => dp
!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

  use constants, only : zero, pi, pi2

  use numerical, only :

  use fileunits, only : ounit, vunit

  use inputlist, only : Wmacros, Wcasing, vcasingtol, vcasingits, vcasingper

  use cputiming, only : Tcasing

  use allglobal, only : myid, ncpu, cpus, MPI_COMM_SPEC, globaljk, Dxyz, Nxyz, ext

!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!


#ifdef OPENMP
  USE OMP_LIB
#endif
  use mpi
  implicit none
  integer   :: ierr, astat, ios, nthreads, ithread
  real(wp)      :: cput, cpui, cpuo=0 ! cpu time; cpu initial; cpu old; 31 Jan 13;


  real(wp), intent(in)     :: teta, zeta ! arbitrary location; Cartesian;
  real(wp), intent(out)    :: gBn ! magnetic field; Cartesian;
  integer, intent(out) :: icasing

  integer, parameter   :: Ndim = 2, Nfun = 1

  integer              :: ldim, lfun, minpts, maxpts, Lrwk, idcuhre, jk, irestart, funcls, key, num, maxsub
  real(wp)                 :: integrals(1:Nfun), low(1:Ndim), upp(1:Ndim), labs, lrel, absest(1:Nfun)
  real(wp), allocatable    :: rwk(:)

! REAL                 :: dvcfield
  external             :: dvcfield


  cpui = MPI_WTIME()
  cpuo = cpui
#ifdef OPENMP
  nthreads = omp_get_max_threads()
#else
  nthreads = 1
#endif


!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

  jk = globaljk ! shorthand; globaljk is a "global" variable which must be passed through to subroutine dvcfield;

!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

  gBn = zero ! initialize intent(out);

!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

  ldim = Ndim ! number of dimensions of the integral; surface integral => number of dimensions = 2;

  low(1) = teta - vcasingper * pi ; upp(1) = teta + vcasingper * pi
  low(2) = zeta - vcasingper * pi ; upp(2) = zeta + vcasingper * pi

  key = 0

  minpts = vcasingits ! minimum number of function evaluations; provided on input;

  num = 65 ! see documentation for dcuhre;

!  maxpts = max( minpts, 3 * num )

  maxpts = 16777216

  lfun = Nfun ! number of functions to be integrated; require three components of magnetic field, Bx, By and Bz; and their derivatives wrt x,y,z;

  labs = vcasingtol ; lrel = vcasingtol ! absolute and relative accuracy requested; vcasingtol is an input parameter;

  maxsub = ( maxpts - num ) / ( 2 * num ) + 1

  Lrwk = maxsub * ( 2 * Ndim + 2 * Nfun + 2 ) + 17 * Nfun + 1


   allocate( rwk(1:Lrwk), stat=astat )
   rwk(1:Lrwk) = zero


  irestart = 0 ; funcls = 0

  do ! will continually call until satisfactory accuracy has been achieved;

   idcuhre = 1

   call DCUHRE( ldim, lfun, low(1:Ndim), upp(1:Ndim), minpts, maxpts, dvcfield, labs, lrel, key, &
                Lrwk, irestart, integrals(1:lfun), absest(1:lfun), funcls, idcuhre, rwk(1:Lrwk) )

   gBn = integrals(1)

   cput = MPI_WTIME()
   select case( idcuhre ) !                                                                                      "123456789012345678901234"
   case(0)      ;
    ;           ; exit
   case(1)      ; write(ounit,1001) cput-cpus, myid, Dxyz(1:3,jk), gBn, absest(1:Nfun), idcuhre, minpts, maxpts, "maxpts too smal;        "
    ;           ;!exit
   case(2)      ; write(ounit,1001) cput-cpus, myid, Dxyz(1:3,jk), gBn, absest(1:Nfun), idcuhre, minpts, maxpts, "illegal key;            "
    ;           ; exit
   case(3)      ; write(ounit,1001) cput-cpus, myid, Dxyz(1:3,jk), gBn, absest(1:Nfun), idcuhre, minpts, maxpts, "illegal Ndim;           "
    ;           ; exit
   case(4)      ; write(ounit,1001) cput-cpus, myid, Dxyz(1:3,jk), gBn, absest(1:Nfun), idcuhre, minpts, maxpts, "key.eq.1 & Ndim.ne.2;   "
    ;           ; exit
   case(5)      ; write(ounit,1001) cput-cpus, myid, Dxyz(1:3,jk), gBn, absest(1:Nfun), idcuhre, minpts, maxpts, "key.eq.2 & Ndim.ne.3;   "
    ;           ; exit
   case(6)      ; write(ounit,1001) cput-cpus, myid, Dxyz(1:3,jk), gBn, absest(1:Nfun), idcuhre, minpts, maxpts, "numfun < 1;             "
    ;           ; exit
   case(7)      ; write(ounit,1001) cput-cpus, myid, Dxyz(1:3,jk), gBn, absest(1:Nfun), idcuhre, minpts, maxpts, "volume is zero;         "
    ;           ; exit
   case(8)      ; write(ounit,1001) cput-cpus, myid, Dxyz(1:3,jk), gBn, absest(1:Nfun), idcuhre, minpts, maxpts, "maxpts < 3*NUM;         "
    ;           ; exit
   case(9)      ; write(ounit,1001) cput-cpus, myid, Dxyz(1:3,jk), gBn, absest(1:Nfun), idcuhre, minpts, maxpts, "maxpts < minpts;        "
    ;           ; exit
   case(10)     ; write(ounit,1001) cput-cpus, myid, Dxyz(1:3,jk), gBn, absest(1:Nfun), idcuhre, minpts, maxpts, "epsabs < 0 & epsrel < 0;"
    ;           ; exit
   case(11)     ; write(ounit,1001) cput-cpus, myid, Dxyz(1:3,jk), gBn, absest(1:Nfun), idcuhre, minpts, maxpts, "NW is too small;        "
    ;           ; exit
   case(12)     ; write(ounit,1001) cput-cpus, myid, Dxyz(1:3,jk), gBn, absest(1:Nfun), idcuhre, minpts, maxpts, "illegal irestart;       "
    ;           ; exit
   case default ; write(ounit,1001) cput-cpus, myid, Dxyz(1:3,jk), gBn, absest(1:Nfun), idcuhre, minpts, maxpts, "tryin' to kill me?      "
    ;           ; exit
   end select

   maxpts = 2 * maxpts ; minpts = funcls ; irestart = 0

   maxsub = ( maxpts - num ) / ( 2 * num ) + 1

   Lrwk = maxsub * ( 2 * Ndim + 2 * Nfun + 2 ) + 17 * Nfun + 1


   deallocate(rwk,stat=astat)



   allocate( rwk(1:Lrwk), stat=astat )
   rwk(1:Lrwk) = zero



  enddo ! end of virtual casing accuracy infinite-do-loop; 10 Apr 13;

#ifdef DEBUG
  ;             ; if( Wcasing ) write(ounit,1001) cput-cpus, myid, Dxyz(1:3,jk), gBn, absest(1:Nfun), idcuhre, minpts, maxpts
#endif

1001 format("casing : ",f10.2," : myid=",i3," ; [x,y,z]=["es10.2" ,"es10.2" ,"es10.2" ]; gBn="es12.4" , ",&
            "err="es8.0" ; ifail="i3" ; min/max calls="2i12" ; "a24)

!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

  icasing = idcuhre ! this is an error flag returned by casing;

!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!


   deallocate(rwk,stat=astat)


!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!


9999 continue
  cput = MPI_WTIME()
  Tcasing = Tcasing + ( cput-cpuo )
  return


!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

end subroutine casing

!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

!> @brief Differential virtual casing integrand
!> \ingroup grp_free-boundary
!>
!> Differential virtual casing integrand
!>
!> @param[in] Ndim number of parameters (==2)
!> @param[in] tz \f$\theta\f$ and \f$\zeta\f$
!> @param[in] Nfun number of function values (==3)
!> @param[out] vcintegrand cartesian components of magnetic field
subroutine dvcfield( Ndim, tz, Nfun, vcintegrand ) ! differential virtual-casing field; format is fixed by NAG requirements;
  use mod_kinds, only: wp => dp
!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

  use constants, only : zero, half, one, three, four

  use numerical, only : small

  use fileunits, only : ounit, vunit

  use inputlist, only : Wcasing, Nvol, Igeometry, Lrad, vcasingeps

  use cputiming, only :

  use allglobal, only : myid, ncpu, cpus, MPI_COMM_SPEC, &
                        pi2nfp, &
                        Mvol, &
                        mn, im, in, &
                        iRbc, iZbs, iRbs, iZbc, &
                        Ate, Aze, Ato, Azo, &
                        TT, &
                        YESstellsym, NOTstellsym, &
                        globaljk, Dxyz, Nxyz, &
                        first_free_bound

!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!


#ifdef OPENMP
  USE OMP_LIB
#endif
  use mpi
  implicit none
  integer   :: ierr, astat, ios, nthreads, ithread
  real(wp)      :: cput, cpui, cpuo=0 ! cpu time; cpu initial; cpu old; 31 Jan 13;


  integer , intent(in)  :: Ndim, Nfun
  real(wp)    , intent(in)  :: tz(1:Ndim)
  real(wp)    , intent(out) :: vcintegrand(1:Nfun) ! integrand; components of magnetic field due to plasma currents in Cartesian coordinates;

  integer               :: ii, mi, ni, ll, ideriv, jk
  real(wp)                  :: dR(0:3), dZ(0:3), gBut, gBuz, gtt, gtz, gzz, sqrtg, Blt, Blz, czeta, szeta, arg, carg, sarg, XX, YY, ZZ, teta, zeta
  real(wp)                  :: jj(1:3), rr(1:3), distance(1:3), firstorderfactor

  real(wp)                  :: XXt, XXz, YYt, YYz, ZZt, ZZz, ds, Bxyz(1:3)

!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

#ifdef DEBUG

   if( Ndim.ne. 2 ) then
     write(6,'("casing :      fatal : myid=",i3," ; Ndim.ne. 2 ; incorrect ;")') myid
     call MPI_ABORT( MPI_COMM_SPEC, 1, ierr )
     stop "casing : Ndim.ne. 2 : incorrect  ;"
    endif


   if( Nfun.ne. 1 ) then
     write(6,'("casing :      fatal : myid=",i3," ; Nfun.ne. 1 ; incorrect ;")') myid
     call MPI_ABORT( MPI_COMM_SPEC, 1, ierr )
     stop "casing : Nfun.ne. 1 : incorrect  ;"
    endif

#endif

!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

  dR(0:3) = zero ; ideriv = 0 ; gBut = zero ; gBuz = zero ! initialize summation of coordinates and tangential field;
  dZ(0:3) = zero

  teta = tz(1) ; zeta = tz(2) ! shorthand; 09 Mar 17;

  jk = globaljk

!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

  select case( Igeometry )

  case( 1 ) ! Igeometry = 1 ; 09 Mar 17;

   if( YESstellsym ) then

    do ii = 1, mn ; mi = im(ii) ; ni = in(ii) ! loop over Fourier modes; construct surface current; slow transform required as position is arbitrary;

     arg = mi * teta - ni * zeta ; carg = cos(arg) ; sarg = sin(arg)

     dR(0) = dR(0) +          (                   iRbc(ii,Nvol) ) * carg
     dR(1) = dR(1) +      (   (   iRbc(ii,Mvol) - iRbc(ii,Nvol) ) * carg                                            ) * half
     dR(2) = dR(2) + mi * ( - (                   iRbc(ii,Nvol) ) * sarg                                            )
     dR(3) = dR(3) - ni * ( - (                   iRbc(ii,Nvol) ) * sarg                                            )

    !dZ(0) = dZ(0) +                                                       (                 iZbs(ii,Nvol) ) * sarg
    !dZ(1) = dZ(1) +      (                                                ( iZbs(ii,Mvol) - iZbs(ii,Nvol) ) * sarg ) * half
    !dZ(2) = dZ(2) + mi * (                                                (                 iZbs(ii,Nvol) ) * carg )
    !dZ(3) = dZ(3) - ni * (                                                (                 iZbs(ii,Nvol) ) * carg )

     do ll = 0, Lrad(Mvol)
      gBut = gBut - ( Aze(Mvol,ideriv,ii)%s(ll) * carg                                    ) * TT(ll,0,1) ! contravariant; Jacobian comes later;
      gBuz = gBuz + ( Ate(Mvol,ideriv,ii)%s(ll) * carg                                    ) * TT(ll,0,1)
     enddo

    enddo ! end of do ii = 1, mn ;

   else ! NOTstellsym ; 08 Feb 16;

    do ii = 1, mn ; mi = im(ii) ; ni = in(ii) ! loop over Fourier modes; construct surface current; slow transform required as position is arbitrary;

     arg = mi * teta - ni * zeta ; carg = cos(arg) ; sarg = sin(arg)

     dR(0) = dR(0) +                              iRbc(ii,Nvol)   * carg +                   iRbs(ii,Nvol)   * sarg
     dR(1) = dR(1) +      (   (   iRbc(ii,Mvol) - iRbc(ii,Nvol) ) * carg + ( iRbs(ii,Mvol) - iRbs(ii,Nvol) ) * sarg ) * half
     dR(2) = dR(2) + mi * ( -                     iRbc(ii,Nvol)   * sarg +                   iRbs(ii,Nvol)   * carg )
     dR(3) = dR(3) - ni * ( -                     iRbc(ii,Nvol)   * sarg +                   iRbs(ii,Nvol)   * carg )

    !dZ(0) = dZ(0) +                              iZbc(ii,Nvol)   * carg +                   iZbs(ii,Nvol)   * sarg
    !dZ(1) = dZ(1) +      (   (   iZbc(ii,Mvol) - iZbc(ii,Nvol) ) * carg + ( iZbs(ii,Mvol) - iZbs(ii,Nvol) ) * sarg ) * half
    !dZ(2) = dZ(2) + mi * ( -                     iZbc(ii,Nvol)   * sarg +                   iZbs(ii,Nvol)   * carg )
    !dZ(3) = dZ(3) - ni * ( -                     iZbc(ii,Nvol)   * sarg +                   iZbs(ii,Nvol)   * carg )

     do ll = 0, Lrad(Mvol)
      gBut = gBut - ( Aze(Mvol,ideriv,ii)%s(ll) * carg + Azo(Mvol,ideriv,ii)%s(ll) * sarg ) * TT(ll,0,1) ! contravariant; Jacobian comes later;
      gBuz = gBuz + ( Ate(Mvol,ideriv,ii)%s(ll) * carg + Ato(Mvol,ideriv,ii)%s(ll) * sarg ) * TT(ll,0,1)
     enddo

    enddo ! end of do ii = 1, mn ;

   endif ! end of if( YESstellsym ) ; 08 Feb 16;

  case( 2 ) ! Igeometry = 2 ; 09 Mar 17;


   if( .true. ) then
     write(6,'("casing :      fatal : myid=",i3," ; .true. ; virtual casing under construction for cylindrical geometry ;")') myid
     call MPI_ABORT( MPI_COMM_SPEC, 1, ierr )
     stop "casing : .true. : virtual casing under construction for cylindrical geometry  ;"
    endif


  case( 3 ) ! Igeometry = 3 ; 09 Mar 17;

   if( YESstellsym ) then

    do ii = 1, mn ; mi = im(ii) ; ni = in(ii) ! loop over Fourier modes; construct surface current; slow transform required as position is arbitrary;

     arg = mi * teta - ni * zeta ; carg = cos(arg) ; sarg = sin(arg)
     dR(0) = dR(0) +          (                   iRbc(ii,Nvol) ) * carg
     dR(1) = dR(1) +      (   (   iRbc(ii,Mvol) - iRbc(ii,Nvol) ) * carg                                            ) * half
     dR(2) = dR(2) + mi * ( - (                   iRbc(ii,Nvol) ) * sarg                                            )
     dR(3) = dR(3) - ni * ( - (                   iRbc(ii,Nvol) ) * sarg                                            )

     dZ(0) = dZ(0) +                                                       (                 iZbs(ii,Nvol) ) * sarg
     dZ(1) = dZ(1) +      (                                                ( iZbs(ii,Mvol) - iZbs(ii,Nvol) ) * sarg ) * half
     dZ(2) = dZ(2) + mi * (                                                (                 iZbs(ii,Nvol) ) * carg )
     dZ(3) = dZ(3) - ni * (                                                (                 iZbs(ii,Nvol) ) * carg )

     if (first_free_bound) then
        do ll = 0, Lrad(Nvol)  ! 1 is for outside thr volume
           gBut = gBut - ( Aze(Nvol,ideriv,ii)%s(ll) * carg                                    ) * TT(ll,1,1) ! contravariant; Jacobian comes later;
           gBuz = gBuz + ( Ate(Nvol,ideriv,ii)%s(ll) * carg                                    ) * TT(ll,1,1)
        enddo
     else
        do ll = 0, Lrad(Mvol)
           gBut = gBut - ( Aze(Mvol,ideriv,ii)%s(ll) * carg                                    ) * TT(ll,0,1) ! contravariant; Jacobian comes later;
           gBuz = gBuz + ( Ate(Mvol,ideriv,ii)%s(ll) * carg                                    ) * TT(ll,0,1)
        enddo
     endif

    enddo ! end of do ii = 1, mn ;

   else ! NOTstellsym ; 08 Feb 16;

    do ii = 1, mn ; mi = im(ii) ; ni = in(ii) ! loop over Fourier modes; construct surface current; slow transform required as position is arbitrary;

     arg = mi * teta - ni * zeta ; carg = cos(arg) ; sarg = sin(arg)

     dR(0) = dR(0) +                              iRbc(ii,Nvol)   * carg +                   iRbs(ii,Nvol)   * sarg
     dR(1) = dR(1) +      (   (   iRbc(ii,Mvol) - iRbc(ii,Nvol) ) * carg + ( iRbs(ii,Mvol) - iRbs(ii,Nvol) ) * sarg ) * half
     dR(2) = dR(2) + mi * ( -                     iRbc(ii,Nvol)   * sarg +                   iRbs(ii,Nvol)   * carg )
     dR(3) = dR(3) - ni * ( -                     iRbc(ii,Nvol)   * sarg +                   iRbs(ii,Nvol)   * carg )

     dZ(0) = dZ(0) +                              iZbc(ii,Nvol)   * carg +                   iZbs(ii,Nvol)   * sarg
     dZ(1) = dZ(1) +      (   (   iZbc(ii,Mvol) - iZbc(ii,Nvol) ) * carg + ( iZbs(ii,Mvol) - iZbs(ii,Nvol) ) * sarg ) * half
     dZ(2) = dZ(2) + mi * ( -                     iZbc(ii,Nvol)   * sarg +                   iZbs(ii,Nvol)   * carg )
     dZ(3) = dZ(3) - ni * ( -                     iZbc(ii,Nvol)   * sarg +                   iZbs(ii,Nvol)   * carg )

     if (first_free_bound) then
        do ll = 0, Lrad(Mvol) ! omit the possible current sheet due to a jump in tangential field at the plasma boundary; Zhu 20190603;
           gBut = gBut - ( Aze(Mvol,ideriv,ii)%s(ll) * carg + Azo(Mvol,ideriv,ii)%s(ll) * sarg ) * TT(ll,1,1) ! contravariant; Jacobian comes later;
           gBuz = gBuz + ( Ate(Mvol,ideriv,ii)%s(ll) * carg + Ato(Mvol,ideriv,ii)%s(ll) * sarg ) * TT(ll,1,1)
        enddo
     else
        do ll = 0, Lrad(Mvol)
           gBut = gBut - ( Aze(Mvol,ideriv,ii)%s(ll) * carg + Azo(Mvol,ideriv,ii)%s(ll) * sarg ) * TT(ll,0,1) ! contravariant; Jacobian comes later;
           gBuz = gBuz + ( Ate(Mvol,ideriv,ii)%s(ll) * carg + Ato(Mvol,ideriv,ii)%s(ll) * sarg ) * TT(ll,0,1)
        enddo
     endif

    enddo ! end of do ii = 1, mn ;

   endif ! end of if( YESstellsym ) ; 08 Feb 16;

  end select ! end of select case( Igeometry ) ; 09 Mar 17;

!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

  select case( Igeometry )

  case( 1 ) ! Igeometry = 1 ; 09 Mar 17;

   gtt = one + dR(2)*dR(2)
   gtz =       dR(2)*dR(3)
   gzz = one + dR(3)*dR(3)

   sqrtg = dR(1)

  case( 2 ) ! Igeometry = 2 ; 09 Mar 17;


   if( .true. ) then
     write(6,'("casing :      fatal : myid=",i3," ; .true. ; virtual casing under construction for cylindrical geometry ;")') myid
     call MPI_ABORT( MPI_COMM_SPEC, 1, ierr )
     stop "casing : .true. : virtual casing under construction for cylindrical geometry  ;"
    endif


  case( 3 ) ! Igeometry = 3 ; 09 Mar 17;

   gtt = dR(2)*dR(2) + dZ(2)*dZ(2)
   gtz = dR(2)*dR(3) + dZ(2)*dZ(3)
   gzz = dR(3)*dR(3) + dZ(3)*dZ(3) + dR(0)*dR(0)

   sqrtg = dR(0) * ( dZ(1) * dR(2) - dR(1) * dZ(2) )

  end select

!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

  Blt = ( gBut * gtt + gBuz * gtz ) / sqrtg
  Blz = ( gBut * gtz + gBuz * gzz ) / sqrtg

!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

  select case( Igeometry )

  case( 1 ) ! Igeometry = 1 ; 09 Mar 17;

   XX =          teta ; XXt =           one ; XXz =          zero
   YY =          zeta ; YYt =          zero ; YYz =           one
   ZZ = dR(0)         ; ZZt = dR(2)         ; ZZz = dR(3)

  case( 2 ) ! Igeometry = 2 ; 09 Mar 17;


   if( .true. ) then
     write(6,'("casing :      fatal : myid=",i3," ; .true. ; virtual casing under construction for cylindrical geometry ;")') myid
     call MPI_ABORT( MPI_COMM_SPEC, 1, ierr )
     stop "casing : .true. : virtual casing under construction for cylindrical geometry  ;"
    endif


  case( 3 ) ! Igeometry = 3 ; toroidal geometry;

   czeta = cos( zeta ) ; szeta = sin( zeta )

   XX = dR(0) * czeta ; XXt = dR(2) * czeta ; XXz = dR(3) * czeta - dR(0) * szeta ! 10 Apr 13;
   YY = dR(0) * szeta ; YYt = dR(2) * szeta ; YYz = dR(3) * szeta + dR(0) * czeta
   ZZ = dZ(0)         ; ZZt = dZ(2)         ; ZZz = dZ(3)

  end select

!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

  rr(1:3) = (/ Dxyz(1,jk) - XX, &
               Dxyz(2,jk) - YY, &
               Dxyz(3,jk) - ZZ /)

  jj(1:3) = (/ Blz * XXt - Blt * XXz, &
               Blz * YYt - Blt * YYz, &
               Blz * ZZt - Blt * ZZz /)

!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

  distance(2) = sum( rr(1:3) * rr(1:3) ) + vcasingeps**2 ! 04 May 17;

  distance(1) = sqrt( distance(2) ) ; distance(3) = distance(1) * distance(2) ! powers of distance; 24 Nov 16;

  firstorderfactor = ( one + three * vcasingeps**2 / distance(2) ) / distance(3) ! 04 May 17;

!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

  Bxyz(1:3) = (/ jj(2) * rr(3) - jj(3) * rr(2), &
                 jj(3) * rr(1) - jj(1) * rr(3), &
                 jj(1) * rr(2) - jj(2) * rr(1)  /)

  vcintegrand(1) = sum( Bxyz(1:3) * Nxyz(1:3,jk) ) * firstorderfactor

!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

!   vcintegrand( 4) = - three * vcintegrand(1) * rr(1) / distance(2)         ! dBxdx; ! need to divide by distance(3) ; 14 Apr 17;
!   vcintegrand( 5) = - three * vcintegrand(1) * rr(2) / distance(2) - jj(3) ! dBxdy;
!   vcintegrand( 6) = - three * vcintegrand(1) * rr(3) / distance(2) + jj(2) ! dBxdz;
!
!   vcintegrand( 7) = - three * vcintegrand(2) * rr(1) / distance(2) + jj(3) ! dBydx;
!   vcintegrand( 8) = - three * vcintegrand(2) * rr(2) / distance(2)         ! dBydy;
!   vcintegrand( 9) = - three * vcintegrand(2) * rr(3) / distance(2) - jj(1) ! dBydz;
!
!   vcintegrand(10) = - three * vcintegrand(3) * rr(1) / distance(2) - jj(2) ! dBzdx;
!   vcintegrand(11) = - three * vcintegrand(3) * rr(2) / distance(2) + jj(1) ! dBzdy;
!   vcintegrand(12) = - three * vcintegrand(3) * rr(3) / distance(2)         ! dBzdz;

!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

  return

!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

end subroutine dvcfield

!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
