!> \file
!> \brief Constructs the field created by the plasma currents, at an arbitrary, external location using virtual casing.

!> \brief Constructs the field created by the plasma currents, at an arbitrary, external location using virtual casing.
!> \ingroup grp_free-boundary
!>
!> Compute the external magnetic field using virtual casing.
!>
!> **Theory and numerics**
!>
!> <ul>
!> <li> Required inputs to this subroutine are the geometry of the plasma boundary,
!>      \f{eqnarray}{ {\bf x}(\theta,\zeta) \equiv x(\theta,\zeta) {\bf i} + y(\theta,\zeta) {\bf j} + z(\theta,\zeta) {\bf k},
!>      \f}
!>      and the tangential field on this boundary,
!>      \f{eqnarray}{ {\bf B}_s=B^\theta {\bf e}_\theta + B^\zeta {\bf e}_\zeta,
!>      \f}
!>      where \f$\theta\f$ and \f$\zeta\f$ are arbitrary poloidal and toroidal angles,
!>      and \f${\bf e}_\theta \equiv \partial {\bf x}/\partial \theta\f$, \f${\bf e}_\zeta \equiv \partial {\bf x}/\partial \zeta\f$.
!>      This routine assumes that the plasma boundary is a flux surface, i.e. \f${\bf B} \cdot {\bf e}_\theta \times {\bf e}_\zeta = 0\f$. </li>
!> <li> The virtual casing principle (Shafranov & Zakharov (1972) \cite y1972_shafranov_zakharov, Lazerson (2012) \cite y2012_lazerson and Hanson (2015) \cite y2015_hanson)
!>      shows that the field outside/inside the plasma arising from plasma currents inside/outside the boundary
!>      is equivalent to the field generated by a surface current,
!>      \f{eqnarray}{ {\bf j} = {\bf B}_s \times {\bf n},
!>      \f}
!>      where \f${\bf n}\f$ is normal to the surface. </li>
!> <li> The field at some arbitrary point, \f$\bar {\bf x}\f$, created by this surface current is given by
!>      \f{eqnarray}{ {\bf B}({\bf \bar x}) = -\frac{1}{4\pi} \int_{\cal S} \frac{\left( {\bf B}_s \times d{\bf s} \right) \times {\bf \hat r}}{r^2},
!>      \f}
!>      where \f$d{\bf s} \equiv {\bf e}_\theta \times {\bf e}_\zeta \; d\theta d\zeta\f$. </li>
!> <li> For ease of notation introduce
!>      \f{eqnarray}{ {\bf J} & \equiv & {\bf B}_s \times d{\bf s} = \alpha \; {\bf e}_\theta - \beta \; {\bf e}_\zeta,
!>      \f}
!>      where \f$\alpha \equiv B_\zeta =  B^\theta g_{\theta\zeta} + B^\zeta g_{\zeta\zeta}\f$ and \f$\beta \equiv B_\theta = B^\theta g_{\theta\theta} + B^\zeta g_{\theta\zeta}\f$. </li>
!> <li> We may write in Cartesian coordinates \f${\bf J} = j_x \; {\bf i} + j_y \; {\bf j} + j_z \; {\bf k}\f$, where
!>      \f{eqnarray}{ j_x     &    =   & \alpha \; x_\theta - \beta \; x_\zeta \\
!>                    j_y     &    =   & \alpha \; y_\theta - \beta \; y_\zeta \\
!>                    j_z     &    =   & \alpha \; z_\theta - \beta \; z_\zeta .
!>      \f} </li>
!> <li> Requiring that the current,
!>      \f{eqnarray}{ {\bf j} & \equiv & \nabla \times {\bf B}
!>                      =      {\sqrt g}^{-1}(\partial_\theta B_\zeta -\partial_\zeta  B_\theta) \; {\bf e}_s
!>                      +      {\sqrt g}^{-1}(\partial_\zeta  B_s     -\partial_s      B_\zeta ) \; {\bf e}_\theta
!>                      +      {\sqrt g}^{-1}(\partial_s      B_\theta-\partial_\theta B_s     ) \; {\bf e}_\zeta,
!>      \f}
!>      has no normal component to the surface, i.e. \f${\bf j}\cdot \nabla s=0\f$,
!>      we obtain the condition \f$\partial_\theta B_\zeta = \partial_\zeta B_\theta\f$, or \f$\partial_\theta \alpha = \partial_\zeta \beta\f$.
!>      In axisymmetric configurations, where \f$\partial_\zeta \beta=0\f$, we must have \f$\partial_\theta \alpha=0\f$. </li>
!> <li> The displacement from an arbitrary point, \f$(X,Y,Z)\f$, to a point, \f$(x,y,z)\f$, that lies on the surface is given
!>      \f{eqnarray}{ {\bf r} \equiv r_x \; {\bf i} + r_y \; {\bf j} + r_z \; {\bf k} = (X-x) \; {\bf i} + (Y-y) \; {\bf j} + (Z-z) \; {\bf k}.
!>      \f} </li>
!> <li> The components of the magnetic field produced by the surface current are then
!>      \f{eqnarray}{ B^x &=& \oint\!\!\!\oint \!d\theta d\zeta \,\,\, (j_y r_z - j_z r_y)/r^3,\\
!>                    B^y &=& \oint\!\!\!\oint \!d\theta d\zeta \,\,\, (j_z r_x - j_x r_z)/r^3,\\
!>                    B^z &=& \oint\!\!\!\oint \!d\theta d\zeta \,\,\, (j_x r_y - j_y r_x)/r^3
!>      \f}
!>      up to a scaling factor \c virtualcasingfactor  \f$=-1/4\pi\f$ that is taken into account at the end. </li>
!> <li> When all is said and done, this routine calculates
!>      \f{eqnarray}{ \int_0^{2\pi} \int_0^{2\pi} \verb+vcintegrand+ \;\; d\theta d\zeta
!>      \f}
!>      for a given \f$(X,Y,Z)\f$, where \c vcintegrand  is given in Eqn.\f$(\ref{eq:integrand_casing})\f$. </li>
!> <li> The surface integral is performed using \c DCUHRE , which
!>      uses an adaptive subdivision strategy and also computes absolute error estimates.
!>      The absolute and relative accuracy required are provided by the \c inputvar \c vcasingtol .
!>      The minimum number of function evaluations is provided by the \c inputvar \c vcasingits. </li>
!> </ul>
!>
!> @param[in] teta \f$\theta\f$
!> @param[in] zeta \f$\zeta\f$
!> @param[out] gBn \f$ \sqrt g {\bf B} \cdot {\bf n}\f$
!> @param[out] icasing return flag from dcuhre()
subroutine casing( teta, zeta, gBn, icasing )

!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

  use constants, only : zero, pi, pi2

  use fileunits, only : ounit, vunit

  use inputlist, only : Wmacros, Wcasing, vcasingtol, vcasingits, vcasingper

  use cputiming, only : Tcasing

  use allglobal, only : myid, ncpu, cpus, MPI_COMM_SPEC, globaljk, Dxyz, Nxyz, ext

!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

  LOCALS

  REAL, intent(in)     :: teta, zeta ! theta and zeta evaluation point on the computational boundary, corresponding to the cartesian evaluation point Dxyz(1:3,globaljk) 
  REAL, intent(out)    :: gBn        ! B.n magnetic field
  INTEGER, intent(out) :: icasing

  INTEGER, parameter   :: Ndim = 2, Nfun = 1

  INTEGER              :: ldim, lfun, minpts, maxpts, Lrwk, idcuhre, irestart, funcls, key, num, maxsub
  REAL                 :: integrals(1:Nfun), low(1:Ndim), upp(1:Ndim), labs, lrel, absest(1:Nfun)
  REAL, allocatable    :: rwk(:)

! REAL                 :: dvcfield
  external             :: dvcfield

  BEGIN(casing)


!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

  gBn = zero ! initialize intent(out);

!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

  ldim = Ndim ! number of dimensions of the integral; surface integral => number of dimensions = 2;

  low(1) = teta - vcasingper * pi ; upp(1) = teta + vcasingper * pi
  low(2) = zeta - vcasingper * pi ; upp(2) = zeta + vcasingper * pi

  key = 0

  minpts = vcasingits ! minimum number of function evaluations; provided on input;

  num = 65 ! see documentation for dcuhre;

!  maxpts = max( minpts, 3 * num )

  maxpts = 16777216

  lfun = Nfun ! number of functions to be integrated; require three components of magnetic field, Bx, By and Bz; and their derivatives wrt x,y,z;

  labs = vcasingtol ; lrel = vcasingtol ! absolute and relative accuracy requested; vcasingtol is an input parameter;

  maxsub = ( maxpts - num ) / ( 2 * num ) + 1

  Lrwk = maxsub * ( 2 * Ndim + 2 * Nfun + 2 ) + 17 * Nfun + 1

  SALLOCATE( rwk, (1:Lrwk), zero )

  irestart = 0 ; funcls = 0

  do ! will continually call until satisfactory accuracy has been achieved;

   idcuhre = 1

   call DCUHRE( ldim, lfun, low(1:Ndim), upp(1:Ndim), minpts, maxpts, dvcfield, labs, lrel, key, &
                Lrwk, irestart, integrals(1:lfun), absest(1:lfun), funcls, idcuhre, rwk(1:Lrwk) )

   gBn = integrals(1)

   cput = GETTIME
   select case( idcuhre ) !                                                                                      "123456789012345678901234"
   case(0)      ;
    ;           ; exit
   case(1)      ; write(ounit,1001) cput-cpus, myid, Dxyz(1:3,globaljk), gBn, absest(1:Nfun), idcuhre, minpts, maxpts, "maxpts too smal;        "
    ;           ;!exit
   case(2)      ; write(ounit,1001) cput-cpus, myid, Dxyz(1:3,globaljk), gBn, absest(1:Nfun), idcuhre, minpts, maxpts, "illegal key;            "
    ;           ; exit
   case(3)      ; write(ounit,1001) cput-cpus, myid, Dxyz(1:3,globaljk), gBn, absest(1:Nfun), idcuhre, minpts, maxpts, "illegal Ndim;           "
    ;           ; exit
   case(4)      ; write(ounit,1001) cput-cpus, myid, Dxyz(1:3,globaljk), gBn, absest(1:Nfun), idcuhre, minpts, maxpts, "key.eq.1 & Ndim.ne.2;   "
    ;           ; exit
   case(5)      ; write(ounit,1001) cput-cpus, myid, Dxyz(1:3,globaljk), gBn, absest(1:Nfun), idcuhre, minpts, maxpts, "key.eq.2 & Ndim.ne.3;   "
    ;           ; exit
   case(6)      ; write(ounit,1001) cput-cpus, myid, Dxyz(1:3,globaljk), gBn, absest(1:Nfun), idcuhre, minpts, maxpts, "numfun < 1;             "
    ;           ; exit
   case(7)      ; write(ounit,1001) cput-cpus, myid, Dxyz(1:3,globaljk), gBn, absest(1:Nfun), idcuhre, minpts, maxpts, "volume is zero;         "
    ;           ; exit
   case(8)      ; write(ounit,1001) cput-cpus, myid, Dxyz(1:3,globaljk), gBn, absest(1:Nfun), idcuhre, minpts, maxpts, "maxpts < 3*NUM;         "
    ;           ; exit
   case(9)      ; write(ounit,1001) cput-cpus, myid, Dxyz(1:3,globaljk), gBn, absest(1:Nfun), idcuhre, minpts, maxpts, "maxpts < minpts;        "
    ;           ; exit
   case(10)     ; write(ounit,1001) cput-cpus, myid, Dxyz(1:3,globaljk), gBn, absest(1:Nfun), idcuhre, minpts, maxpts, "epsabs < 0 & epsrel < 0;"
    ;           ; exit
   case(11)     ; write(ounit,1001) cput-cpus, myid, Dxyz(1:3,globaljk), gBn, absest(1:Nfun), idcuhre, minpts, maxpts, "NW is too small;        "
    ;           ; exit
   case(12)     ; write(ounit,1001) cput-cpus, myid, Dxyz(1:3,globaljk), gBn, absest(1:Nfun), idcuhre, minpts, maxpts, "illegal irestart;       "
    ;           ; exit
   case default ; write(ounit,1001) cput-cpus, myid, Dxyz(1:3,globaljk), gBn, absest(1:Nfun), idcuhre, minpts, maxpts, "tryin' to kill me?      "
    ;           ; exit
   end select

   maxpts = 2 * maxpts ; minpts = funcls ; irestart = 0

   maxsub = ( maxpts - num ) / ( 2 * num ) + 1

   Lrwk = maxsub * ( 2 * Ndim + 2 * Nfun + 2 ) + 17 * Nfun + 1

   DALLOCATE(rwk)

   SALLOCATE(rwk, (1:Lrwk), zero)


  enddo ! end of virtual casing accuracy infinite-do-loop; 10 Apr 13;

#ifdef DEBUG
  ;             ; if( Wcasing ) write(ounit,1001) cput-cpus, myid, Dxyz(1:3,globaljk), gBn, absest(1:Nfun), idcuhre, minpts, maxpts
#endif

1001 format("casing : ",f10.2," : myid=",i3," ; [x,y,z]=["es10.2" ,"es10.2" ,"es10.2" ]; gBn="es12.4" , ",&
            "err="es8.0" ; ifail="i3" ; min/max calls="2i12" ; "a24)

!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

  icasing = idcuhre ! this is an error flag returned by casing;

!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

  DALLOCATE(rwk)

!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

  RETURN(casing)

!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

end subroutine casing

!> \brief Compute the field produced by the plasma currents, at an arbitrary, external location using virtual casing.
!> \ingroup grp_free-boundary
!>
!> casinggrid() computes the virtual casing field using a fixed resolution grid on the plasma boundary, in contrast to casing() which uses an adaptive integration routine.
!> Because the evaluation positions are known in advance, the most expensive terms of the computation (surfacecurrents, or in the casing() routine dvcfield) are precomputed. 
!> The integral computed by casinggrid() is 
!> \f{eqnarray}{ \int_0^{2\pi} \int_0^{2\pi} \frac{{\bf j}(\theta, \zeta) \times {\bf D}(\theta, \zeta)}{\|{\bf D}(\theta', \zeta')\|^3}+ \;\; d\theta d\zeta  
!>  \f}
!> with \f${\bf r}\f$ approximately the distance vector from an evaluation point of the current surface \f${\bf x}(\theta, \zeta)\f$ to the 
!> external point \f$(x,y,z)\f$, and the exact formula includes a regularization factor \f$\epsilon\f$  Eqn.\f$(\ref{eq:vcasing_distance})\f$.
!>
!> @param[in] xyz \f$(x,y,z)\f$ cartesian coordinates on the computational boundary
!> @param[in] nxyz cartesian normal vector on the computational boundary
!> @param[in] Pbxyz  array of cartesian coordinates on the plasma boundary
!> @param[in] Jxyz array of surface currents \f${\bf B}_{Plasma} \cdot {\bf e}_\theta \times {\bf e}_\zeta \;\f$ on the plasma boundary
!> @param[in] vcstride integer stride for the fixed resolution grid. vcstride = 1 computes the integral at full resolution, vcstride = 2 computes the integral at half resolution, etc.
!> @param[out] gBn normal field \f${\bf B}_{Plasma} \cdot n \;\f$ on the computational boundary
subroutine casinggrid( xyz, nxyz,  Pbxyz, Jxyz, vcstride, gBn)
  use constants, only : zero, one, three, pi2

  use fileunits, only : ounit, vunit

  use inputlist, only : vcasingeps, vcNz, vcNt

  use allglobal, only : myid, ncpu, cpus, MPI_COMM_SPEC !, Pbxyz, Jxyz

  LOCALS

  REAL, intent(in)     :: xyz(3) ! arbitrary location; Cartesian;
  REAL, intent(in)     :: nxyz(3) ! surface normal on the computational boundary; Cartesian;
  REAL, intent(in)     :: Pbxyz(1:vcNz*vcNt, 1:3), Jxyz(1:vcNz*vcNt, 1:3) 
  INTEGER, intent(in)  :: vcstride
  REAL, intent(out)    :: gBn ! B.n on the computational boundary;
  
  REAL :: rr(1:3),  distance(1:3), jj(1:3), Bxyz(1:3), accumulator, firstorderfactor
  INTEGER :: plasmaNtz, jk

!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  ! plasmaNtz = SIZE(Pbxyz, 1)
  plasmaNtz = vcNz*vcNt
  ! loop over the high resolution plasma boundary (inner boundary for virtual casing)
  do jk = 1, plasmaNtz, vcstride ;
      ! distance vector between point on computational boundary and point on plasma boundary
      rr = xyz - Pbxyz(jk, 1:3)
      jj = Jxyz(jk, 1:3)

    !-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
    
      distance(2) = sum( rr * rr ) + vcasingeps**2 ! 04 May 17;
      distance(1) = sqrt( distance(2) ) ; 
      distance(3) = distance(1) * distance(2) ! powers of distance; 24 Nov 16;
    
      firstorderfactor = ( one + three * vcasingeps**2 / distance(2) ) / distance(3) ! 04 May 17;
    
    !-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

      Bxyz(1:3) = (/ jj(2) * rr(3) - jj(3) * rr(2), &
                     jj(3) * rr(1) - jj(1) * rr(3), &
                     jj(1) * rr(2) - jj(2) * rr(1)  /)
    
      ! Accumulate B.r/r^3 contributions 
      gBn = gBn + sum( Bxyz * nxyz ) * firstorderfactor
 enddo
 gBn = gBn * pi2 * pi2 / (plasmaNtz / vcstride) 
 return

end subroutine casinggrid


!> \brief Compute the position and surface current on the plasma boundary for the virtual casing
!> \ingroup grp_free-boundary
!> **Calculation of integrand**
!>
!> <ul>
!> <li> An adaptive integration is used to compute the integrals.
!>      Consequently, the magnetic field tangential to the plasma boundary is required at an arbitrary point.
!>      This is computed, as always, from \f${\bf B} = \nabla \times {\bf A}\f$, and this provides \f${\bf B} = B^\theta {\bf e}_\theta + B^\zeta {\bf e}_\zeta\f$.
!>      Recall that \f$B^s=0\f$ by construction on the plasma boundary.
!>
!> </li>
!> <li> Then, the metric elements \f$g_{\theta\theta}\f$, \f$g_{\theta\zeta}\f$ and \f$g_{\zeta\zeta}\f$ are computed.
!>      These are used to "lower" the components of the magnetic field, \f${\bf B} = B_\theta \nabla \theta + B_\zeta \nabla \zeta\f$.
!>
!> </li>
!> <li> The distance between the "evaluate" point, \f$(X,Y,Z)\f$, and the given point on the surface, \f$(x,y,z)\f$ is computed. </li>
!> <li> If the computational boundary becomes too close to the plasma boundary, the distance is small and this causes problems for the numerics.
!>      I have tried to regularize this problem by introducing \f$\epsilon \equiv \f$\c inputvar \c vcasingeps.
!>      Let the "distance" be
!>      \f{eqnarray}{ D \equiv \sqrt{(X-x)^2 + (Y-y)^2 + (Z-Z)^2} + \epsilon^2.
!>      \label{eq:vcasing_distance}  \f} </li>
!> <li> On taking the limit that \f$\epsilon \rightarrow 0\f$, the virtual casing integrand is
!>       \f{eqnarray}{ \verb+vcintegrand+ \equiv ( B_x n_x + B_y n_y + B_z n_z ) ( 1 + 3 \epsilon^2 / D^2 ) / D^3, \label{eq:integrand_casing}
!>       \f}
!>      where the normal vector is \f${\bf n} \equiv n_x {\bf i} + n_y {\bf j} + n_z {\bf k}\f$.
!>      The normal vector, \c Nxyz , to the computational boundary (which does not change) is computed in preset().
!>      \todo This needs to be revised.
!>
!> </li>
!> </ul>
!>
!> @param[in] teta \f$\theta\f$
!> @param[in] zeta \f$\zeta\f$
!> @param[out] pxyz \f$(x,y,z)\f$ cartesian coordinates on the plasma boundary
!> @param[out] jj Surface current \f${\bf B}_{Plasma} \cdot {\bf e}_\theta \times {\bf e}_\zeta \;\f$ on the plasma boundary
subroutine surfacecurrent( teta, zeta, pxyz, jj)

  !-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
    use constants, only : zero, half, one
  
    use inputlist, only : Nvol, Igeometry, Lrad
  
    use allglobal, only : myid, ncpu, cpus, MPI_COMM_SPEC, &
                          Mvol, &
                          mn, im, in, &
                          iRbc, iZbs, iRbs, iZbc, &
                          Ate, Aze, Ato, Azo, &
                          TT, &
                          YESstellsym, &
                          first_free_bound
  
  !-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
    LOCALS
    
    REAL    , intent(in)  :: teta, zeta ! theta and zeta coordinates on the plasma boundary
    REAL    , intent(out) :: jj(1:3),   ! Cartesian surface current components on the plasma boundary
    REAL    , intent(out) :: pxyz(1:3)  ! Position on the plasma boundary
  
    INTEGER               :: ii, mi, ni, ll, ideriv
    REAL                  :: dR(0:3), dZ(0:3), gBut, gBuz, gtt, gtz, gzz, sqrtg, Blt, Blz, czeta, szeta, arg, carg, sarg
  
    REAL                  :: XXt, XXz, YYt, YYz, ZZt, ZZz, ds
  
  !-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
    dR(0:3) = zero ; ideriv = 0 ; gBut = zero ; gBuz = zero ! initialize summation of coordinates and tangential field;
    dZ(0:3) = zero
  
  !-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
    select case( Igeometry )
  
    case( 1 ) ! Igeometry = 1 ; 09 Mar 17;
  
     if( YESstellsym ) then
  
      do ii = 1, mn ; mi = im(ii) ; ni = in(ii) ! loop over Fourier modes; construct surface current; slow transform required as position is arbitrary;
  
       arg = mi * teta - ni * zeta ; carg = cos(arg) ; sarg = sin(arg)
  
       dR(0) = dR(0) +          (                   iRbc(ii,Nvol) ) * carg
       dR(1) = dR(1) +      (   (   iRbc(ii,Mvol) - iRbc(ii,Nvol) ) * carg                                            ) * half
       dR(2) = dR(2) + mi * ( - (                   iRbc(ii,Nvol) ) * sarg                                            )
       dR(3) = dR(3) - ni * ( - (                   iRbc(ii,Nvol) ) * sarg                                            )
  
      !dZ(0) = dZ(0) +                                                       (                 iZbs(ii,Nvol) ) * sarg
      !dZ(1) = dZ(1) +      (                                                ( iZbs(ii,Mvol) - iZbs(ii,Nvol) ) * sarg ) * half
      !dZ(2) = dZ(2) + mi * (                                                (                 iZbs(ii,Nvol) ) * carg )
      !dZ(3) = dZ(3) - ni * (                                                (                 iZbs(ii,Nvol) ) * carg )
  
       do ll = 0, Lrad(Mvol)
        gBut = gBut - ( Aze(Mvol,ideriv,ii)%s(ll) * carg                                    ) * TT(ll,0,1) ! contravariant; Jacobian comes later;
        gBuz = gBuz + ( Ate(Mvol,ideriv,ii)%s(ll) * carg                                    ) * TT(ll,0,1)
       enddo
  
      enddo ! end of do ii = 1, mn ;
  
     else ! NOTstellsym ; 08 Feb 16;
  
      do ii = 1, mn ; mi = im(ii) ; ni = in(ii) ! loop over Fourier modes; construct surface current; slow transform required as position is arbitrary;
  
       arg = mi * teta - ni * zeta ; carg = cos(arg) ; sarg = sin(arg)
  
       dR(0) = dR(0) +                              iRbc(ii,Nvol)   * carg +                   iRbs(ii,Nvol)   * sarg
       dR(1) = dR(1) +      (   (   iRbc(ii,Mvol) - iRbc(ii,Nvol) ) * carg + ( iRbs(ii,Mvol) - iRbs(ii,Nvol) ) * sarg ) * half
       dR(2) = dR(2) + mi * ( -                     iRbc(ii,Nvol)   * sarg +                   iRbs(ii,Nvol)   * carg )
       dR(3) = dR(3) - ni * ( -                     iRbc(ii,Nvol)   * sarg +                   iRbs(ii,Nvol)   * carg )
  
      !dZ(0) = dZ(0) +                              iZbc(ii,Nvol)   * carg +                   iZbs(ii,Nvol)   * sarg
      !dZ(1) = dZ(1) +      (   (   iZbc(ii,Mvol) - iZbc(ii,Nvol) ) * carg + ( iZbs(ii,Mvol) - iZbs(ii,Nvol) ) * sarg ) * half
      !dZ(2) = dZ(2) + mi * ( -                     iZbc(ii,Nvol)   * sarg +                   iZbs(ii,Nvol)   * carg )
      !dZ(3) = dZ(3) - ni * ( -                     iZbc(ii,Nvol)   * sarg +                   iZbs(ii,Nvol)   * carg )
  
       do ll = 0, Lrad(Mvol)
        gBut = gBut - ( Aze(Mvol,ideriv,ii)%s(ll) * carg + Azo(Mvol,ideriv,ii)%s(ll) * sarg ) * TT(ll,0,1) ! contravariant; Jacobian comes later;
        gBuz = gBuz + ( Ate(Mvol,ideriv,ii)%s(ll) * carg + Ato(Mvol,ideriv,ii)%s(ll) * sarg ) * TT(ll,0,1)
       enddo
  
      enddo ! end of do ii = 1, mn ;
  
     endif ! end of if( YESstellsym ) ; 08 Feb 16;
  
    case( 2 ) ! Igeometry = 2 ; 09 Mar 17;
  
     FATAL( casing, .true., virtual casing under construction for cylindrical geometry )
  
    case( 3 ) ! Igeometry = 3 ; 09 Mar 17;
  
     if( YESstellsym ) then
  
      do ii = 1, mn ; mi = im(ii) ; ni = in(ii) ! loop over Fourier modes; construct surface current; slow transform required as position is arbitrary;
  
       arg = mi * teta - ni * zeta ; carg = cos(arg) ; sarg = sin(arg)
       dR(0) = dR(0) +          (                   iRbc(ii,Nvol) ) * carg
       dR(1) = dR(1) +      (   (   iRbc(ii,Mvol) - iRbc(ii,Nvol) ) * carg                                            ) * half
       dR(2) = dR(2) + mi * ( - (                   iRbc(ii,Nvol) ) * sarg                                            )
       dR(3) = dR(3) - ni * ( - (                   iRbc(ii,Nvol) ) * sarg                                            )
  
       dZ(0) = dZ(0) +                                                       (                 iZbs(ii,Nvol) ) * sarg
       dZ(1) = dZ(1) +      (                                                ( iZbs(ii,Mvol) - iZbs(ii,Nvol) ) * sarg ) * half
       dZ(2) = dZ(2) + mi * (                                                (                 iZbs(ii,Nvol) ) * carg )
       dZ(3) = dZ(3) - ni * (                                                (                 iZbs(ii,Nvol) ) * carg )
  
       if (first_free_bound) then
          do ll = 0, Lrad(Nvol)  ! 1 is for outside thr volume
             gBut = gBut - ( Aze(Nvol,ideriv,ii)%s(ll) * carg                                    ) * TT(ll,1,1) ! contravariant; Jacobian comes later;
             gBuz = gBuz + ( Ate(Nvol,ideriv,ii)%s(ll) * carg                                    ) * TT(ll,1,1)
          enddo
       else
          do ll = 0, Lrad(Mvol)
             gBut = gBut - ( Aze(Mvol,ideriv,ii)%s(ll) * carg                                    ) * TT(ll,0,1) ! contravariant; Jacobian comes later;
             gBuz = gBuz + ( Ate(Mvol,ideriv,ii)%s(ll) * carg                                    ) * TT(ll,0,1)
          enddo
       endif
  
      enddo ! end of do ii = 1, mn ;
  
     else ! NOTstellsym ; 08 Feb 16;
  
      do ii = 1, mn ; mi = im(ii) ; ni = in(ii) ! loop over Fourier modes; construct surface current; slow transform required as position is arbitrary;
  
       arg = mi * teta - ni * zeta ; carg = cos(arg) ; sarg = sin(arg)
  
       dR(0) = dR(0) +                              iRbc(ii,Nvol)   * carg +                   iRbs(ii,Nvol)   * sarg
       dR(1) = dR(1) +      (   (   iRbc(ii,Mvol) - iRbc(ii,Nvol) ) * carg + ( iRbs(ii,Mvol) - iRbs(ii,Nvol) ) * sarg ) * half
       dR(2) = dR(2) + mi * ( -                     iRbc(ii,Nvol)   * sarg +                   iRbs(ii,Nvol)   * carg )
       dR(3) = dR(3) - ni * ( -                     iRbc(ii,Nvol)   * sarg +                   iRbs(ii,Nvol)   * carg )
  
       dZ(0) = dZ(0) +                              iZbc(ii,Nvol)   * carg +                   iZbs(ii,Nvol)   * sarg
       dZ(1) = dZ(1) +      (   (   iZbc(ii,Mvol) - iZbc(ii,Nvol) ) * carg + ( iZbs(ii,Mvol) - iZbs(ii,Nvol) ) * sarg ) * half
       dZ(2) = dZ(2) + mi * ( -                     iZbc(ii,Nvol)   * sarg +                   iZbs(ii,Nvol)   * carg )
       dZ(3) = dZ(3) - ni * ( -                     iZbc(ii,Nvol)   * sarg +                   iZbs(ii,Nvol)   * carg )
  
       if (first_free_bound) then
          do ll = 0, Lrad(Mvol) ! omit the possible current sheet due to a jump in tangential field at the plasma boundary; Zhu 20190603;
             gBut = gBut - ( Aze(Mvol,ideriv,ii)%s(ll) * carg + Azo(Mvol,ideriv,ii)%s(ll) * sarg ) * TT(ll,1,1) ! contravariant; Jacobian comes later;
             gBuz = gBuz + ( Ate(Mvol,ideriv,ii)%s(ll) * carg + Ato(Mvol,ideriv,ii)%s(ll) * sarg ) * TT(ll,1,1)
          enddo
       else
          do ll = 0, Lrad(Mvol)
             gBut = gBut - ( Aze(Mvol,ideriv,ii)%s(ll) * carg + Azo(Mvol,ideriv,ii)%s(ll) * sarg ) * TT(ll,0,1) ! contravariant; Jacobian comes later;
             gBuz = gBuz + ( Ate(Mvol,ideriv,ii)%s(ll) * carg + Ato(Mvol,ideriv,ii)%s(ll) * sarg ) * TT(ll,0,1)
          enddo
       endif
  
      enddo ! end of do ii = 1, mn ;
  
     endif ! end of if( YESstellsym ) ; 08 Feb 16;
  
    end select ! end of select case( Igeometry ) ; 09 Mar 17;
  
  !-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
    select case( Igeometry )
  
    case( 1 ) ! Igeometry = 1 ; 09 Mar 17;
  
     gtt = one + dR(2)*dR(2)
     gtz =       dR(2)*dR(3)
     gzz = one + dR(3)*dR(3)
  
     sqrtg = dR(1)
  
    case( 2 ) ! Igeometry = 2 ; 09 Mar 17;
  
     FATAL( casing, .true., virtual casing under construction for cylindrical geometry )
  
    case( 3 ) ! Igeometry = 3 ; 09 Mar 17;
  
     gtt = dR(2)*dR(2) + dZ(2)*dZ(2)
     gtz = dR(2)*dR(3) + dZ(2)*dZ(3)
     gzz = dR(3)*dR(3) + dZ(3)*dZ(3) + dR(0)*dR(0)
  
     sqrtg = dR(0) * ( dZ(1) * dR(2) - dR(1) * dZ(2) )
  
    end select
  
  !-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
    Blt = ( gBut * gtt + gBuz * gtz ) / sqrtg
    Blz = ( gBut * gtz + gBuz * gzz ) / sqrtg
  
  !-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
    select case( Igeometry )
  
    case( 1 ) ! Igeometry = 1 ; 09 Mar 17;
  
      pxyz(1:3) = (/ teta , zeta, dR(0) /)
      XXt =           one ; XXz = zero
      YYt =          zero ; YYz = one
      ZZt = dR(2)         ; ZZz = dR(3)
  
    case( 2 ) ! Igeometry = 2 ; 09 Mar 17;
      
     FATAL( casing, .true., virtual casing under construction for cylindrical geometry )
  
    case( 3 ) ! Igeometry = 3 ; toroidal geometry;
  
     czeta = cos( zeta ) ; szeta = sin( zeta )
  
     pxyz(1:3) = (/ dR(0) * czeta, dR(0) * szeta , dZ(0) /) 
     XXt = dR(2) * czeta ; XXz = dR(3) * czeta - dR(0) * szeta ! 10 Apr 13;
     YYt = dR(2) * szeta ; YYz = dR(3) * szeta + dR(0) * czeta
     ZZt = dZ(2)         ; ZZz = dZ(3)
  
    end select
  
  !-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
    jj(1:3) = (/ Blz * XXt - Blt * XXz, &
                 Blz * YYt - Blt * YYz, &
                 Blz * ZZt - Blt * ZZz /)
  
    return
  
  !-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
  end subroutine surfacecurrent 

!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

!> @brief Differential virtual casing integrand
!> \ingroup grp_free-boundary
!>
!> Differential virtual casing integrand with the calling convention required by NAG for the adaptive integration routine.  
!> This function wraps surfacecurrent and uses a global variable globaljk to determine the position on the computational boundary (not thread safe!). 
!>
!> @param[in] Ndim number of parameters (==2)
!> @param[in] tz \f$\theta\f$ and \f$\zeta\f$
!> @param[in] Nfun number of function values (==3)
!> @param[out] vcintegrand cartesian components of magnetic field
subroutine dvcfield( Ndim, tz, Nfun, vcintegrand )

  use constants, only : zero, half, one, three

  use inputlist, only : vcasingeps

  use allglobal, only : myid, ncpu, cpus, MPI_COMM_SPEC, &
                        globaljk, Dxyz, Nxyz, first_free_bound

  
  !-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
  LOCALS
  
  INTEGER , intent(in)  :: Ndim, Nfun
  REAL    , intent(in)  :: tz(1:Ndim)
  REAL    , intent(out) :: vcintegrand(1:Nfun) ! integrand; components of magnetic field due to plasma currents in Cartesian coordinates;
 
  REAL                  :: jj(1:3), &       ! Cartesian surface current components on the plasma boundary
                           pxyz(1:3), &     ! Position on the plasma boundary
                           rr(1:3), &       ! distance vector between evaluation point on the computational boundary and the current surface point
                           distance(1:3), & ! powers of distance |(x-x')|, |(x-x')|^2, |(x-x')|^3 including a small eps to avoid division by zero
                           Bxyz(1:3), firstorderfactor

#ifdef DEBUG
  FATAL( casing, Ndim.ne. 2, incorrect )
  FATAL( casing, Nfun.ne. 1, incorrect )
#endif
!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

  call surfacecurrent(tz(1), tz(2), pxyz, jj)

  ! distance vector between point on computational boundary and point on plasma boundary
  rr(1:3) = Dxyz(1:3,globaljk) - pxyz(1:3)

!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

  distance(2) = sum( rr(1:3) * rr(1:3) ) + vcasingeps**2 ! 04 May 17;
  distance(1) = sqrt( distance(2) ) ; 
  distance(3) = distance(1) * distance(2) ! powers of distance; 24 Nov 16;

  firstorderfactor = ( one + three * vcasingeps**2 / distance(2) ) / distance(3) ! 04 May 17;

!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

  Bxyz(1:3) = (/ jj(2) * rr(3) - jj(3) * rr(2), &
                 jj(3) * rr(1) - jj(1) * rr(3), &
                 jj(1) * rr(2) - jj(2) * rr(1)  /)

  vcintegrand(1) = sum( Bxyz(1:3) * Nxyz(1:3,globaljk) ) * firstorderfactor

  !-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

  ! vcintegrand( 4) = - three * vcintegrand(1) * rr(1) / distance(2) ! dBxdx; ! need to divide by distance(3) ; 14 Apr 17;
  !   vcintegrand( 5) = - three * vcintegrand(1) * rr(2) / distance(2) - jj(3) ! dBxdy;
  !   vcintegrand( 6) = - three * vcintegrand(1) * rr(3) / distance(2) + jj(2) ! dBxdz;
  !
  !   vcintegrand( 7) = - three * vcintegrand(2) * rr(1) / distance(2) + jj(3) ! dBydx;
  !   vcintegrand( 8) = - three * vcintegrand(2) * rr(2) / distance(2)         ! dBydy;
  !   vcintegrand( 9) = - three * vcintegrand(2) * rr(3) / distance(2) - jj(1) ! dBydz;
  !
  !   vcintegrand(10) = - three * vcintegrand(3) * rr(1) / distance(2) - jj(2) ! dBzdx;
  !   vcintegrand(11) = - three * vcintegrand(3) * rr(2) / distance(2) + jj(1) ! dBzdy;
  !   vcintegrand(12) = - three * vcintegrand(3) * rr(3) / distance(2)         ! dBzdz;

  !-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  return

end subroutine dvcfield
