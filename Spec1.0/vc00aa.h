!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

!latex \item Constructs field due to plasma currents at external location using virtual casing.

!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

!latex \end{enumerate} \subsection{theory and numerics} \begin{enumerate}

!latex \item Required inputs to this subroutine are the geometry of the plasma boundary, 
!latex       \be {\bf x}(\t,\z) \equiv x(\t,\z) {\bf i} + y(\t,\z) {\bf j} + z(\t,\z) {\bf k},
!latex       \ee
!latex       and the tangential field on this boundary, 
!latex       \be {\bf B}_s=B^\t {\bf e}_\t + B^z {\bf e}_\z,
!latex       \ee
!latex       where $\t$ and $\z$ are arbitrary poloidal and toroidal angles,
!latex       and ${\bf e}_\t \equiv \partial {\bf x}/\partial \t$, ${\bf e}_\z \equiv \partial {\bf x}/\partial \z$.
!latex       This routine assumes $B^\s=0$.

!latex \item The virtual casing principle \cite{Shafranov_Zakharov_72}
!latex       shows that the field outside/inside the plasma arising from plasma currents inside/outside the boundary is equivalent to the field generated by a surface current,
!latex       \be {\bf j} = {\bf B}_s \times {\bf n},
!latex       \ee
!latex       where ${\bf n}$ is normal to the surface.

!latex \item The field created by this surface current is given by
!latex       \be {\bf B}({\bf \bar x}) = \int_{\cal S} \frac{\left( {\bf B}_s \times d{\bf s} \right) \times {\bf \hat r}}{r^2},
!latex       \ee
!latex       where $d{\bf s} \equiv {\bf e}_\t \times {\bf e}_\z \; d\t d\z$.

!latex \item For ease of notation introduce
!latex       \be {\bf J} & \equiv & {\bf B}_s \times d{\bf s} = \alpha \; {\bf e}_\t - \beta \; {\bf e}_\z,
!latex       \ee
!latex       where $\alpha \equiv B_\z =  B^\t g_{\t\z} + B^\z g_{\z\z}$ and $\beta \equiv B_\t = B^\t g_{\t\t} + B^\z g_{\t\z}$,

!latex \item We may write in Cartesian coordinates ${\bf J} = j_x \; {\bf i} + j_y \; {\bf j} + j_z \; {\bf k}$, where
!latex       \be j_x     &    =   & \alpha \; x_\t - \beta \; x_\z \\
!latex           j_y     &    =   & \alpha \; y_\t - \beta \; y_\z \\
!latex           j_z     &    =   & \alpha \; z_\t - \beta \; z_\z .
!latex       \ee

!latex \item Requiring that the current,
!latex       \be {\bf j} & \equiv & \nabla \times {\bf B}
!latex                       =      {\sqrt g}^{-1}(\partial_\t B_\z-\partial_\z B_\t) \; {\bf e}_\s
!latex                       +      {\sqrt g}^{-1}(\partial_\z B_\s-\partial_\s B_\z) \; {\bf e}_\t
!latex                       +      {\sqrt g}^{-1}(\partial_\s B_\t-\partial_\t B_\s) \; {\bf e}_\z,
!latex       \ee
!latex       has no normal component to the surface, i.e. ${\bf j}\cdot \nabla s=0$,
!latex       we obtain the condition $\partial_\t B_\z = \partial_\z B_\t$, or $\partial_\t \alpha = \partial_\z \beta$.
!latex       In axisymmetric configurations, where $\partial_\z \beta=0$, we must have $\partial_\t \alpha=0$.

!latex \item The displacement from a point, $(x,y,z)$, to a point, $(X,Y,Z)$ that lies on the surface is given 
!latex       \be {\bf r} \equiv r_x \; {\bf i} + r_y \; {\bf j} + r_z \; {\bf k} = (x-X) \; {\bf i} + (y-Y) \; {\bf j} + (z-Z) \; {\bf k}.
!latex       \ee

!latex \item The components of the magnetic field produced by the surface current are then
!latex       \be B^x &=&  \ooint (j_y r_z - j_z r_y)/r^3,\\
!latex           B^y &=&  \ooint (j_z r_x - j_x r_z)/r^3,\\
!latex           B^z &=&  \ooint (j_x r_y - j_y r_x)/r^3
!latex       \ee

!latex \item The surface integral is performed using the NAG routine \verb+D01EAF+, which 
!latex       uses an adaptive subdivision strategy, and also computes absolute error estimates.
!latex       The absolute and relative accuracy required are provided by the inputs \verb+absreq+ and \verb+relreq+.

!latex \item It will be convenient to have the derivatives:
!latex       \be \frac{\partial B^x}{\partial x} & = & \ooint \left[ -3 (j_y r_z - j_z r_y) (x-X) / r^5 \;\;\;\;\;\;\;\;\;\;\;\;     \right], \\
!latex           \frac{\partial B^x}{\partial y} & = & \ooint \left[ -3 (j_y r_z - j_z r_y) (y-Y) / r^5 - j_z/r^3                    \right], \\
!latex           \frac{\partial B^x}{\partial z} & = & \ooint \left[ -3 (j_y r_z - j_z r_y) (z-Z) / r^5 + j_y/r^3                    \right], \\
!latex           \frac{\partial B^y}{\partial x} & = & \ooint \left[ -3 (j_z r_x - j_x r_z) (x-X) / r^5 + j_z/r^3                    \right], \\
!latex           \frac{\partial B^y}{\partial y} & = & \ooint \left[ -3 (j_z r_x - j_x r_z) (y-Y) / r^5 \;\;\;\;\;\;\;\;\;\;\;\;\;   \right], \\
!latex           \frac{\partial B^y}{\partial z} & = & \ooint \left[ -3 (j_z r_x - j_x r_z) (z-Z) / r^5 - j_x/r^3                    \right], \\
!latex           \frac{\partial B^z}{\partial x} & = & \ooint \left[ -3 (j_x r_y - j_y r_x) (x-X) / r^5 - j_y/r^3                    \right], \\
!latex           \frac{\partial B^z}{\partial y} & = & \ooint \left[ -3 (j_x r_y - j_y r_x) (y-Y) / r^5 + j_x/r^3                    \right], \\
!latex           \frac{\partial B^z}{\partial z} & = & \ooint \left[ -3 (j_x r_y - j_y r_x) (z-Z) / r^5 \;\;\;\;\;\;\;\;\;\;\;\;\;   \right].
!latex       \ee

!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

subroutine vc00aa( lxyz, Bxyz, dBxyzdxyz, ivirtualfail )
  
!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
  use constants, only : zero, pi2
  
  use numerical, only : vsmall, small
  
  use fileunits, only : ounit, vunit
  
  use inputlist, only : Wmacros, Wvc00aa, ext, absreq, relreq
  
  use cputiming, only : Tvc00aa
  
  use allglobal, only : myid, ncpu, cpus, xyz, virtualcasingfactor, Ltangent
  
!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
  LOCALS
  
  REAL, intent(in)  :: lxyz(1:3) ! arbitrary location; Cartesian;
  REAL, intent(out) :: Bxyz(1:3) ! magnetic field; Cartesian;
  REAL, intent(out) :: dBxyzdxyz(1:3,1:3) ! magnetic field; Cartesian; derivatives wrt x,y,z;
  INTEGER           :: ivirtualfail
  
  INTEGER           :: NDIM, MINCLS, MAXCLS, NFUN, LENWRK, RR, ifail
  real              :: integrals(1:12), lower(1:2), upper(1:2), labsreq, lrelreq, abserr(1:12)
  REAL, allocatable :: WRKSTR(:)
  
  INTEGER           :: ncall = 0
  
  CHARACTER         :: svol*4
  
  EXTERNAL          :: virtualcasingintegrands
  
  BEGIN(vc00aa)
  
!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
  xyz(1:3) = lxyz(1:3) ! this is a "global" variable which must be passed through to subroutine virtualcasingintegrands; 03 Apr 13;
  
!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
  Bxyz(1:3) = zero ; dBxyzdxyz(1:3,1:3) = zero ! initialize intent(out);
  
!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
  if( Wvc00aa ) then ! prepare output file;
   ncall = ncall + 1
   write(svol,'(i4.4)')ncall
   open(vunit+myid,file="."//trim(ext)//".vcint."//svol,status="unknown")
   write(vunit+myid,'(3es23.15)')xyz(1:3)
  endif
  
!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
  NDIM          = 2             ! number of dimensions of the integral; surface integral => number of dimensions = 2;
  lower(1:NDIM) = zero          ! lower limits of the integrals; integrate over entire surface;
  upper(1:NDIM) =  pi2          ! upper limits of the integrals; integrate over entire surface;
  MINCLS        = 2**4 * 2**4   ! minimum number of function evaluations;
  
  if( NDIM .lt. 11 ) then ; RR = 2**NDIM + 2 * NDIM**2 + 2 * NDIM + 1
  else                    ; RR = 1 + NDIM * ( 4 * NDIM**2 - 6 * NDIM + 14 ) / 3
  endif
  
  MAXCLS = 2**8 * max( 2*MINCLS, RR ) ! maximum number of function evaluations;
  
  NFUN    = 3 + 9   ! number of functions to be integrated; require three components of magnetic field, Bx, By and Bz; and their derivatives wrt x,y,z;
  
  labsreq = absreq ! absolute accuracy requested; this is an input parameter;
  lrelreq = relreq ! relative accuracy requested; this is an input parameter;
  
  LENWRK  = 6 * NDIM + 9 * NFUN + ( NDIM + NFUN + 2 ) * (1 + MAXCLS / RR )
  
  LENWRK  = 2**3 * LENWRK ! NEED TO CHECK LENWRK;
  
  LENWRK  = max( LENWRK, 8 * NDIM + 11 * NFUN + 3 )
  
  RALLOCATE(WRKSTR,(1:LENWRK))
  
!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
  do ! will continually call until satisfactory accuracy has been achieved;
   
   ifail = 1
   call D01EAF( NDIM, lower(1:NDIM), upper(1:NDIM), MINCLS, MAXCLS, NFUN, virtualcasingintegrands, labsreq, lrelreq, LENWRK, WRKSTR, integrals(1:12), abserr(1:12), ifail )
   
   integrals(1:12) = integrals(1:12) * virtualcasingfactor
   
   Bxyz(1:3) = integrals(1:3)
   
   dBxyzdxyz(1,1:3) = integrals( 4: 6)
   dBxyzdxyz(2,1:3) = integrals( 7: 9)
   dBxyzdxyz(3,1:3) = integrals(10:12)
   
   cput = GETTIME
   select case( ifail ) !                                                                                                   1234567890123456789012345678901234
   case(0)      ; if( Wvc00aa ) write(ounit,1001)cput-cpus, myid, xyz(1:3), Bxyz(1:3), abserr(1:3), ifail, mincls, maxcls                                       ; exit
   case(1)      ; if( Wvc00aa ) write(ounit,1001)cput-cpus, myid, xyz(1:3), Bxyz(1:3), abserr(1:3), ifail, mincls, maxcls, "maxcls too small for reqd accuracy"
   case(2)      ;               write(ounit,1001)cput-cpus, myid, xyz(1:3), Bxyz(1:3), abserr(1:3), ifail, mincls, maxcls, "lenwrk too small ; poor accuracy ;" ; exit
   case(3)      ; if( Wvc00aa ) write(ounit,1001)cput-cpus, myid, xyz(1:3), Bxyz(1:3), abserr(1:3), ifail, mincls, maxcls, "maxcls too small for continuation "
   case(4)      ;               write(ounit,1001)cput-cpus, myid, xyz(1:3), Bxyz(1:3), abserr(1:3), ifail, mincls, maxcls, "input error                       " ; exit
   case default ;               write(ounit,1001)cput-cpus, myid, xyz(1:3), Bxyz(1:3), abserr(1:3), ifail, mincls, maxcls, "illegal ifail on exit             " ; exit
   end select
   
   maxcls = 2*maxcls ; mincls = -1
   
  enddo ! end of virtual casing accuracy infinite-do-loop; 10 Apr 13;

#ifdef DEBUG
  ;               if( Wvc00aa ) write(ounit,1001)cput-cpus, myid, xyz(1:3), Bxyz(1:3), abserr(1:3), ifail, mincls, maxcls
#endif
  
1001 format("vc00aa : ",f10.2," : myid=",i3," ; [x,y,z]=["es13.5" ,"es13.5" ,"es13.5" ]; B[xyz]=["es15.7" ,"es15.7" ,"es15.7" ], err="3es8.0" ; ifail="i2" ; min/max cls="2i12" ;"a35)
  
!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

  ivirtualfail = ifail ! this is an error flag returned by vc00aa;
  
!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
  DEALLOCATE(WRKSTR)
  
!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
  if( Wvc00aa ) close(vunit+myid)
  
!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
  RETURN(vc00aa)
  
!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
end subroutine vc00aa

!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!


!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!

subroutine virtualcasingintegrands( NDIM, TZ, NFUN, FF ) ! differential field; format is fixed by NAG requirements;
  
!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
  use constants, only : zero, one, three
  
  use numerical, only :
  
  use fileunits, only : ounit, vunit
  
  use inputlist, only : Wvc00aa, Nvol, Igeometry, pknot, curtor, curpol, Lrad
  
  use cputiming, only : 

  use allglobal, only : myid, ncpu, cpus, pi2nfp, Mvol, mn, im, in, iRbc, iZbs, iRbs, iZbc, xyz, Ate, Ato, TTll, Ltangent, NOTstellsym
  
!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
  LOCALS
  
  INTEGER , intent(in)  :: NDIM, NFUN
  REAL    , intent(in)  :: TZ(NDIM)
  REAL    , intent(out) :: FF(NFUN) ! integrand; components of magnetic field due to plasma currents in Cartesian coordinates;
  
  INTEGER               :: ii, mi, ni, ll, ideriv
  REAL                  :: dR(0:3), dZ(0:3), Blow(2:3), coszeta, sinzeta, arg, carg, sarg, XX, YY, ZZ
  REAL                  :: jx,jy,jz, distance, distancesqd
  
  REAL                  :: XXt, XXz, YYt, YYz, ZZt, ZZz, ds

!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
#ifdef DEBUG
  FATALMESS(vc00aa, NDIM.ne. 2, incorrect )
  FATALMESS(vc00aa, NFUN.ne.12, incorrect )
  FATALMESS(vc00aa, NOTstellsym, under construction )
#endif
  
!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
!latex \end{enumerate} \subsection{selection of virtual casing surface and tangential field} \begin{enumerate}
  
!latex \item The virtual casing tangent field is given by the field in the outermost volume, i.e. \verb+lvol=Nvol+ that is tangent to this interface.
  
  dR(0:3) = zero ; dZ(0:3) = zero ; ideriv = 0

  Blow(2:3) = (/ curtor, curpol /) ! initialize summation of coordinates and tangential field;
  
  do ii = 1, mn ; mi = im(ii) ; ni = in(ii) ! loop over Fourier modes; construct surface current; slow transform required as position is arbitrary;
   
   arg = mi * TZ(1) - ni * TZ(2) ; carg = cos(arg) ; sarg = sin(arg)
   
   dR(0) = dR(0) + iRbc(ii,Nvol) * carg            !   R       ; recall that iRbc is a global variable containing the interface geometry;
   dR(2) = dR(2) + iRbc(ii,Nvol) * sarg * ( - mi ) ! d R / d t
   dR(3) = dR(3) + iRbc(ii,Nvol) * sarg * ( + ni ) ! d R / d z
   
   dZ(0) = dZ(0) + iZbs(ii,Nvol) * sarg            !   Z       ; recall that iRbc is a global variable containing the interface geometry;
   dZ(2) = dZ(2) + iZbs(ii,Nvol) * carg * ( + mi ) ! d Z / d t
   dZ(3) = dZ(3) + iZbs(ii,Nvol) * carg * ( - ni ) ! d Z / d z
   
   do ll = 0, Lrad(Mvol)
   Blow(2:3) = Blow(2:3) + Ate(Mvol,ideriv,ii)%s(ll) * TTll(ll,0,0) * carg * (/ + mi, - ni /) ! co-variant components of the field at the inner vacuum interface; 03 Apr 13;
   enddo

#ifdef DEBUG
   FATALMESS(vc0aaa, NOTstellsym, need to include non stellarator symmetric terms )
#endif
   
  enddo ! end of do ii = 1, mn ;
  
!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
  coszeta = cos( TZ(2) ) ; sinzeta = sin( TZ(2) ) 
  

  select case( Igeometry )
   
  case( 3 ) ! toroidal geometry;

   FATALMESS( vc00aa, pknot.ne.1, under construction )

   XX = dR(0) * coszeta ; XXt = dR(2) * coszeta ; XXz = dR(3) * coszeta - dR(0) * sinzeta ! 10 Apr 13;
   YY = dR(0) * sinzeta ; YYt = dR(2) * sinzeta ; YYz = dR(3) * sinzeta + dR(0) * coszeta   
   ZZ = dZ(0)           ; ZZt = dZ(2)           ; ZZz = dZ(3)
   
  case default
   
   FATALMESS(vc00aa, .true., Igeometry not supported )
   
  end select
  
  
  jx = Blow(3) * XXt - Blow(2) * XXz
  jy = Blow(3) * YYt - Blow(2) * YYz
  jz = Blow(3) * ZZt - Blow(2) * ZZz
  
  distance = sqrt( (xyz(1)-XX)**2 + (xyz(2)-YY)**2 + (xyz(3)-ZZ)**2 )
  
  FF(1) = jy * ( xyz(3)-ZZ ) - jz * ( xyz(2)-YY ) ! dBx;
  FF(2) = jz * ( xyz(1)-XX ) - jx * ( xyz(3)-ZZ ) ! dBy;
  FF(3) = jx * ( xyz(2)-YY ) - jy * ( xyz(1)-XX ) ! dBz;
  
!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
  select case( Ltangent ) ! determines whether derivatives are required;
   
  case( 0 )
   
   FF(4:12) = one ! provide dummy values that should be simple to integrate to arbitrary absolute/relative accuracy;
   
!  case( 1 )
!   
!   distancesqd = distance**2
!   
!   FF( 4) = - three * FF(1) * ( xyz(1)-XX ) / distancesqd      ! dBxdx;
!   FF( 5) = - three * FF(1) * ( xyz(2)-YY ) / distancesqd - jz ! dBxdy;
!   FF( 6) = - three * FF(1) * ( xyz(3)-ZZ ) / distancesqd + jy ! dBxdz;
!   
!   FF( 7) = - three * FF(2) * ( xyz(1)-XX ) / distancesqd + jz ! dBydx;
!   FF( 8) = - three * FF(2) * ( xyz(2)-YY ) / distancesqd      ! dBydy;
!   FF( 9) = - three * FF(2) * ( xyz(3)-ZZ ) / distancesqd - jx ! dBydz;
!   
!   FF(10) = - three * FF(3) * ( xyz(1)-XX ) / distancesqd - jz ! dBzdx;
!   FF(11) = - three * FF(3) * ( xyz(2)-YY ) / distancesqd + jx ! dBzdy;
!   FF(12) = - three * FF(3) * ( xyz(3)-ZZ ) / distancesqd      ! dBzdz;
!   
  case default
   
   FATALMESS(vc00aa, .true., invalid Ltangent )
   
  end select
  
!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
  FF(1:12) = FF(1:12) / distance**3 ! return the components of the magnetic field, Bx, By and Bz, and their derivatives;
  
!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
  if( Wvc00aa ) write(vunit+myid,'(5es23.15)') TZ(1:2), FF(1:3)
  
!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
  return
  
!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
  
end subroutine virtualcasingintegrands

!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!
